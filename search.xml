<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Blog and Learning</title>
    <url>/2023/03/27/About-Blog/</url>
    <content><![CDATA[<h3 id="Reasons-to-Write-a-Blog">Reasons to Write a Blog</h3>
<p>这个博客是在一年之前建立的，但由于我觉得写博客很累就一直搁置着。在一年多的学习过程中，我时常感觉到遗忘和不知从何而来。前几天在翻找课程攻略时，我发现一个博客的主人曾几年不间断地每天写博客，我当然做不到这样，但是受到了莫大的激励，于是想起了这个博客，想要借此记录自己的学习和生活。不过说到做博客的经验的话，我是一点没有，但由于高中的时候写了不少随笔，因此我是擅长自言自语的。做这个博客，除了减少遗忘以外，更多的是给自己看，给自己一个念想，记录下自己的脚步。另外想说的还是，由于是给自己写的博客，技术纰漏很多，日记式自言自语的话很多，很多评价和感觉不成熟也不专业，很多感情很直接却也真实，看客们权当小孩子的把戏一笑而过。(不过应该也没人会看😆)</p>
<h3 id="Site-Log">Site Log</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>2023/3/28<br>
这几天多上传了几篇，发现文章的属性从学习记录变成随笔、日记和对未来的思考了，本来是督促学习的，现在为了写博客忘记了😆。</p>
</li>
<li class="lvl-2">
<p>2023/3/31<br>
感觉可以把课外阅读书单也加到博客里。</p>
</li>
<li class="lvl-2">
<p>2023/4/24<br>
水了好几篇博客文章，开了一些坑，不知道什么时候能补完。</p>
</li>
<li class="lvl-2">
<p>2023/5/1<br>
五一快乐！</p>
</li>
<li class="lvl-2">
<p>2023/5/14<br>
hexo d部署出了点问题，不知道是代理问题还是网络波动</p>
</li>
<li class="lvl-2">
<p>2023/6/5<br>
期末事情变多了😭</p>
</li>
<li class="lvl-2">
<p>2023/7/1<br>
转眼间居然已经七月了</p>
</li>
</ul>
<span id="more"></span>
<h3 id="Lesson-List-and-Progress">Lesson List and Progress</h3>
<h4 id="Math">Math</h4>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Maki Topology</strong><br>
Learning…<br>
rest video</p>
</li>
<li class="lvl-4">
<p><strong>Maki Abstract algebra</strong><br>
Learning…<br>
rest video</p>
</li>
</ul>
<h4 id="Computer-Science">Computer Science</h4>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>MIT-Missing-Semester</strong></p>
</li>
<li class="lvl-4">
<p><strong>CS106B/X</strong><br>
rest project</p>
</li>
<li class="lvl-4">
<p><strong>CS106L</strong><br>
rest project</p>
</li>
<li class="lvl-4">
<p><strong>CMU 15-213: CSAPP</strong><br>
rest lab</p>
</li>
<li class="lvl-4">
<p><strong>CS144</strong><br>
rest project</p>
</li>
<li class="lvl-4">
<p><strong>CS50ai</strong><br>
rest project</p>
</li>
<li class="lvl-4">
<p><strong>CS61A</strong></p>
</li>
<li class="lvl-4">
<p><strong>CS61B</strong><br>
rest lab</p>
</li>
<li class="lvl-4">
<p><strong>CS61C</strong><br>
rest multithreading lab</p>
</li>
<li class="lvl-4">
<p><strong>MIT 6.031: Software Construction</strong><br>
Learning…<br>
rest note problem</p>
</li>
<li class="lvl-4">
<p><strong>MIT 6.S081: Operating System Engineering</strong><br>
Learning…<br>
rest video lab</p>
</li>
<li class="lvl-4">
<p><strong>Hung-yi Lee Machine Learning</strong><br>
Maybe Learning later…<br>
rest video hw</p>
</li>
<li class="lvl-4">
<p><strong>GAMES101</strong><br>
Maybe Learning later…</p>
</li>
<li class="lvl-4">
<p><strong>CS162</strong><br>
Learning…</p>
</li>
<li class="lvl-4">
<p><strong>CS110L</strong><br>
Maybe Learning later…</p>
</li>
<li class="lvl-4">
<p><strong>USTC Computer Networking</strong></p>
</li>
</ul>
<h3 id="Book-List">Book List</h3>
<h4 id="Computer-Science-2">Computer Science</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>算法导论</p>
</li>
<li class="lvl-2">
<p>算法第四版</p>
</li>
<li class="lvl-2">
<p>数据结构和算法分析 C语言版</p>
</li>
<li class="lvl-2">
<p>C++ Primer</p>
</li>
<li class="lvl-2">
<p>C++ Primer Plus</p>
</li>
<li class="lvl-2">
<p>深入理解计算机系统</p>
</li>
<li class="lvl-2">
<p>计算机网络 自顶向下方法</p>
</li>
<li class="lvl-2">
<p>离散数学及其应用</p>
</li>
</ul>
<h3 id="Disadvantage-Analysis-😭">Disadvantage Analysis 😭</h3>
<p>整理一下目前学习过程中欠缺的地方</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>英语问题</p>
<ul class="lvl-2">
<li class="lvl-4">网课能听懂了，但是字幕辅助还是挺重要，听力有点进步</li>
<li class="lvl-4">短文本教程可以看懂，长文本看的吃力，阅读论文感觉很吃力</li>
<li class="lvl-4">慢慢进步吧，感觉主要问题还是出在看的耐心不够，读长文献很不想读</li>
<li class="lvl-4">背单词之类的</li>
</ul>
</li>
<li class="lvl-2">
<p>数学问题</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>离散、组合</strong>没学过，算法分析看的挺吃力</li>
<li class="lvl-4">找门课学学</li>
<li class="lvl-4">想学学其他<strong>数学课</strong>，时间有点跟不上</li>
</ul>
</li>
<li class="lvl-2">
<p>电子问题</p>
<ul class="lvl-2">
<li class="lvl-4">无<strong>电子基础</strong>，缺少对硬件元件的基本认识，缺少对电路的认识</li>
<li class="lvl-4"><strong>信号与系统</strong>不熟</li>
</ul>
</li>
<li class="lvl-2">
<p>算法问题</p>
<ul class="lvl-2">
<li class="lvl-4">题写的很少，只会写一点链表</li>
<li class="lvl-4">得刷点<strong>力扣、洛谷</strong>啥的</li>
<li class="lvl-4">可以看看算法书、算法相关的网站之类的</li>
</ul>
</li>
<li class="lvl-2">
<p>开发问题</p>
<ul class="lvl-2">
<li class="lvl-4">开发经验很少，遇到项目开发和课程作业总是力不从心</li>
<li class="lvl-4">coding的熟练度不够</li>
<li class="lvl-4">合作开发的经验不够</li>
<li class="lvl-4">可以尝试下<strong>github造轮子的项目</strong></li>
</ul>
</li>
<li class="lvl-2">
<p>语言问题</p>
<ul class="lvl-2">
<li class="lvl-4">CJP三门都用过，但用的不熟，常用的包和库也不熟</li>
<li class="lvl-4">开发训练</li>
<li class="lvl-4">想学新语言（<strong>Rust</strong>？），时间有点不够</li>
</ul>
</li>
<li class="lvl-2">
<p>前端问题</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>前端</strong>一点不会，不懂html，不懂Javascript，不懂CSS</li>
<li class="lvl-4">找门课学学，找点资料看看</li>
</ul>
</li>
<li class="lvl-2">
<p>计算机网络</p>
<ul class="lvl-2">
<li class="lvl-4">计算机网络学的很早，学的不熟，快忘光了</li>
</ul>
</li>
<li class="lvl-2">
<p>数据库问题</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>数据库</strong>一点没学过</li>
</ul>
</li>
<li class="lvl-2">
<p>机器学习</p>
<ul class="lvl-2">
<li class="lvl-4">了解大致概念但不深</li>
</ul>
</li>
<li class="lvl-2">
<p>嵌入式</p>
<ul class="lvl-2">
<li class="lvl-4">嵌入式方面想了解下大致概念，微处理器之类的</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Plan</tag>
      </tags>
  </entry>
  <entry>
    <title>About Math</title>
    <url>/2023/04/29/About-Math/</url>
    <content><![CDATA[<h3 id="Introduction">Introduction</h3>
<p>介绍有关数学学习的问题</p>
<h3 id="Links">Links</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://www.bilibili.com/video/BV1XT4y1z78e">how to learn math</a></li>
<li class="lvl-2"><a href="https://www.bilibili.com/video/BV1kY4y1R76G">lesson list</a></li>
</ul>
<span id="more"></span>
<h3 id="Branch-of-mathematics">Branch of mathematics</h3>
<p><img src="/2023/04/29/About-Math/math.png" alt><br>
<img src="/2023/04/29/About-Math/layer0.png" alt><br>
<img src="/2023/04/29/About-Math/layer1.png" alt><br>
<img src="/2023/04/29/About-Math/layer21.png" alt><br>
<img src="/2023/04/29/About-Math/layer22.png" alt><br>
<img src="/2023/04/29/About-Math/layer23.png" alt><br>
<img src="/2023/04/29/About-Math/layer3.png" alt></p>
<h4 id="线性代数">线性代数</h4>
<h4 id="数学分析">数学分析</h4>
<h4 id="点集拓扑">点集拓扑</h4>
<h4 id="复分析">复分析</h4>
<h4 id="群论和抽象代数">群论和抽象代数</h4>
<h4 id="伽罗瓦理论">伽罗瓦理论</h4>
<h4 id="微分几何">微分几何</h4>
<h4 id="代数拓扑">代数拓扑</h4>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Plan</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Literature and Philosophy</title>
    <url>/2023/03/31/Literature-and-Philosophy/</url>
    <content><![CDATA[<h3 id="Book-List-2">Book List</h3>
<span id="more"></span>
<h4 id="Literature">Literature</h4>
<h5 id="德">德</h5>
<ul class="lvl-0">
<li class="lvl-2">魔山</li>
</ul>
<h5 id="中">中</h5>
<ul class="lvl-0">
<li class="lvl-2">活着</li>
</ul>
<h4 id="Philosophy">Philosophy</h4>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>Plan</tag>
      </tags>
  </entry>
  <entry>
    <title>Hung-yi Lee ML Lecture 3: Image as input</title>
    <url>/2023/07/05/Hung-yi-Lee-ML-Lecture3/</url>
    <content><![CDATA[<h3 id="Convolutional-Neural-Network-CNN">Convolutional Neural Network(CNN)</h3>
<ul class="lvl-0">
<li class="lvl-2">卷积神经网络被广泛应用于图像识别领域，是一种带约束的神经网络架构，简化了Fully Connected Network的复杂性，并且对图像识别做了很多特化，另外值得一提的是，谷歌的AlphaGO也使用了卷积神经网络用于接收19*19的围棋棋盘输入，可见CNN的使用范围不仅仅是图像识别，具有相似结构的问题都可以使用CNN的模型进行训练。</li>
</ul>
<span id="more"></span>
<h3 id="深度学习">深度学习</h3>
<ul class="lvl-0">
<li class="lvl-2">为何深度学习可以兼有</li>
</ul>
<h3 id="HW3-CNN">HW3 CNN</h3>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hung-yi Lee ML Lecture 2: What to do if my network fails to train</title>
    <url>/2023/07/05/Hung-yi-Lee-ML-Lecture2/</url>
    <content><![CDATA[<h3 id="Optimization">Optimization</h3>
<ul class="lvl-0">
<li class="lvl-2">局部最小值 local minima</li>
<li class="lvl-2">鞍点 saddle point</li>
<li class="lvl-2">在多维度笛卡尔空间中，你以为的局部最小值很可能是鞍点，因为多出了很多个维度的方向可以走</li>
</ul>
<h3 id="batch-and-momentum">batch and momentum</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>分批次训练的速度和优势比较</p>
</li>
<li class="lvl-2">
<p>动量法改进梯度下降</p>
</li>
</ul>
<h3 id="自动调整学习速率">自动调整学习速率</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>\sigma与梯度的关系</p>
</li>
<li class="lvl-2">
<p>学习速率与时间的关系</p>
<ul class="lvl-2">
<li class="lvl-4">逐渐下降decay</li>
<li class="lvl-4">模拟退火warmup</li>
</ul>
</li>
</ul>
<h3 id="loss函数">loss函数</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>改变loss函数可以改变地形！(梯度下降中的多变量函数)</p>
<ul class="lvl-2">
<li class="lvl-4">MSE</li>
<li class="lvl-4">Cross-entropy等价于极大似然法，运用在向量输出的神经网络中</li>
</ul>
</li>
</ul>
<h3 id="HW2-Classification">HW2 Classification</h3>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter</title>
    <url>/2023/06/19/jupyter/</url>
    <content><![CDATA[<h3 id="Intro">Intro</h3>
<p>jupyter是一个基于web的可交互的应用程序，广泛用于数据分析中，同时支持多种编程语言。</p>
<h3 id="Links">Links</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://jupyter.org/try-jupyter/lab/">jupyter lab</a></p>
</li>
</ul>
<span id="more"></span>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Tools</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>Common Code</title>
    <url>/2023/06/10/Common-Code/</url>
    <content><![CDATA[<h3 id="ASCII码">ASCII码</h3>
<p><img src="/2023/06/10/Common-Code/ASCII.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2"><a href="http://asciitable.com/">ascii码参考网站</a></li>
<li class="lvl-2">\x1b -&gt; ESC 很特殊， \x1b[ 后可以带上不同的东西，用于终端控制和仿真</li>
</ul>
<span id="more"></span>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Tools</category>
      </categories>
      <tags>
        <tag>ASCII</tag>
      </tags>
  </entry>
  <entry>
    <title>USTC Computer Networking Chapter8</title>
    <url>/2023/06/04/USTC-Computer-Networking-Chapter8/</url>
    <content><![CDATA[<h3 id="第八章-网络安全">第八章 网络安全</h3>
<span id="more"></span>
<h4 id="加密">加密</h4>
<h5 id="对称密钥">对称密钥</h5>
<ul class="lvl-0">
<li class="lvl-2">DES</li>
<li class="lvl-2">3DES</li>
<li class="lvl-2">AES</li>
</ul>
<h5 id="非对称密钥">非对称密钥</h5>
<ul class="lvl-0">
<li class="lvl-2">RSA</li>
</ul>
<h4 id="认证">认证</h4>
<ul class="lvl-0">
<li class="lvl-2">重复</li>
<li class="lvl-2">中间人攻击</li>
</ul>
<h4 id="报文完整性">报文完整性</h4>
<ul class="lvl-0">
<li class="lvl-2">数字签名</li>
<li class="lvl-2">散列函数算法
<ul class="lvl-2">
<li class="lvl-4">MD5</li>
<li class="lvl-4">SHA-1</li>
<li class="lvl-4">SHA-256</li>
</ul>
</li>
</ul>
<h4 id="密钥分发和证书">密钥分发和证书</h4>
<ul class="lvl-0">
<li class="lvl-2">KDC是非对称加密的权威</li>
<li class="lvl-2">CA是公开密钥的权威</li>
</ul>
<h4 id="各层次安全性">各层次安全性</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>安全电子邮件PGP</p>
</li>
<li class="lvl-2">
<p>安全套接字层SSL</p>
</li>
<li class="lvl-2">
<p>IPsec</p>
<ul class="lvl-2">
<li class="lvl-4">AH</li>
<li class="lvl-4">ESP</li>
</ul>
</li>
<li class="lvl-2">
<p>IEEE 802.11安全性</p>
<ul class="lvl-2">
<li class="lvl-4">WEP</li>
</ul>
</li>
</ul>
<h4 id="防火墙">防火墙</h4>
<h4 id="攻击和对策">攻击和对策</h4>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>USTC Computer Networking Chapter6</title>
    <url>/2023/06/03/USTC-Computer-Networking-Chapter6/</url>
    <content><![CDATA[<h3 id="第六章-链路层和局域网">第六章 链路层和局域网</h3>
<span id="more"></span>
<p><img src="/2023/06/03/USTC-Computer-Networking-Chapter6/d1.png" alt><br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/d2.png" alt></p>
<h4 id="差错检测和纠正">差错检测和纠正</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>奇偶校验<br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/c1.png" alt></p>
</li>
<li class="lvl-2">
<p>checksum校验和<br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/c2.png" alt></p>
</li>
<li class="lvl-2">
<p>CRC循环冗余校验<br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/c3.png" alt><br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/c4.png" alt></p>
</li>
<li class="lvl-2">
<p>其数学推导用到了模2运算，即加减不进位不借位，加减等价于异或</p>
</li>
</ul>
<h4 id="多点访问控制MAC">多点访问控制MAC</h4>
<p><img src="/2023/06/03/USTC-Computer-Networking-Chapter6/m1.png" alt><br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/m2.png" alt></p>
<h4 id="局域网LANs">局域网LANs</h4>
<h5 id="地址解析协议ARP">地址解析协议ARP</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>MAC地址<br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/a1.png" alt><br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/a2.png" alt></p>
</li>
<li class="lvl-2">
<p>Broadcast address = FF-FF-FF-FF-FF-FF</p>
</li>
<li class="lvl-2">
<p>ARP<br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/a3.png" alt></p>
</li>
</ul>
<h5 id="以太网Ethernet">以太网Ethernet</h5>
<p><img src="/2023/06/03/USTC-Computer-Networking-Chapter6/e1.png" alt><br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/e2.png" alt><br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/e3.png" alt></p>
<h5 id="无线局域网WLAN">无线局域网WLAN</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>IEEE 802.11 Wireless LAN<br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/w1.png" alt><br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/w2.png" alt><br>
<img src="/2023/06/03/USTC-Computer-Networking-Chapter6/w3.png" alt></p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>USTC Computer Networking Chapter5</title>
    <url>/2023/05/31/USTC-Computer-Networking-Chapter5/</url>
    <content><![CDATA[<h3 id="第五章-网络层-控制平面">第五章 网络层 控制平面</h3>
<span id="more"></span>
<h4 id="路由选择算法">路由选择算法</h4>
<ul class="lvl-0">
<li class="lvl-2">link state routing(LS) -&gt; Dijkstra算法，全局的</li>
<li class="lvl-2">distance vector routing -&gt; Bellman-Ford算法，分布式<br>
<img src="/2023/05/31/USTC-Computer-Networking-Chapter5/d1.png" alt></li>
</ul>
<h4 id="内路由">内路由</h4>
<ul class="lvl-0">
<li class="lvl-2">RIP<br>
<img src="/2023/05/31/USTC-Computer-Networking-Chapter5/n1.png" alt></li>
<li class="lvl-2">OSPF<br>
<img src="/2023/05/31/USTC-Computer-Networking-Chapter5/n2.png" alt></li>
</ul>
<h4 id="外路由">外路由</h4>
<ul class="lvl-0">
<li class="lvl-2">BGP<br>
<img src="/2023/05/31/USTC-Computer-Networking-Chapter5/b1.png" alt><br>
<img src="/2023/05/31/USTC-Computer-Networking-Chapter5/b2.png" alt></li>
</ul>
<h4 id="SDN控制平面">SDN控制平面</h4>
<ul class="lvl-0">
<li class="lvl-2">逻辑上集中的控制平面，分离了数据平面和控制平面</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>USTC Computer Networking Chapter4</title>
    <url>/2023/05/30/USTC-Computer-Networking-Chapter4/</url>
    <content><![CDATA[<h3 id="第四章-网络层-数据平面">第四章 网络层 数据平面</h3>
<h4 id="数据平面和控制平面">数据平面和控制平面</h4>
<span id="more"></span>
<p><img src="/2023/05/30/USTC-Computer-Networking-Chapter4/p1.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/p2.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/p3.png" alt></p>
<h4 id="路由器组成">路由器组成</h4>
<h4 id="IP">IP</h4>
<p><img src="/2023/05/30/USTC-Computer-Networking-Chapter4/ip1.png" alt></p>
<h5 id="IP数据报">IP数据报</h5>
<p><img src="/2023/05/30/USTC-Computer-Networking-Chapter4/ip2.png" alt></p>
<h5 id="分片和重组">分片和重组</h5>
<p><img src="/2023/05/30/USTC-Computer-Networking-Chapter4/ip3.png" alt></p>
<h5 id="IPv4地址">IPv4地址</h5>
<p><img src="/2023/05/30/USTC-Computer-Networking-Chapter4/ip4.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/ip5.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/ip6.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/ip7.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/ip8.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/ip9.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/ip10.png" alt></p>
<h5 id="DHCP">DHCP</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>运行在UDP之上，自动帮用户配置好ip、mask、local nameserver、默认网关<br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/dhcp1.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/dhcp2.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/dhcp3.png" alt></p>
</li>
</ul>
<h5 id="NAT">NAT</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>NAT使用内网专用ip地址，这些地址不会在互联网中被用作数据传递<br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/nat1.png" alt></p>
</li>
<li class="lvl-2">
<p>提高了安全性和ip地址的有效数量，存在如何内网穿透的问题</p>
</li>
</ul>
<h5 id="IPv6地址">IPv6地址</h5>
<p><img src="/2023/05/30/USTC-Computer-Networking-Chapter4/ip61.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/ip62.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/ip63.png" alt></p>
<h4 id="SDN">SDN</h4>
<p><img src="/2023/05/30/USTC-Computer-Networking-Chapter4/s1.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/s2.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/s3.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/s4.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>流表<br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/s5.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/s6.png" alt><br>
<img src="/2023/05/30/USTC-Computer-Networking-Chapter4/s7.png" alt></p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireshark</title>
    <url>/2023/05/29/Wireshark/</url>
    <content><![CDATA[<h3 id="Introduction">Introduction</h3>
<p>Wireshark是一个网络包抓取和分析工具，支持各层各类网络协议。</p>
<span id="more"></span><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Tools</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>USTC Computer Networking Chapter3</title>
    <url>/2023/05/28/USTC-Computer-Networking-Chapter3/</url>
    <content><![CDATA[<h3 id="第三章-传输层">第三章 传输层</h3>
<h4 id="多路复用-解复用">多路复用/解复用</h4>
<ul class="lvl-0">
<li class="lvl-2">TCP和UDP各自的2^16个端口实现了多路复用，将IP的端到端通信进化到了进程到进程通信</li>
</ul>
<span id="more"></span>
<h4 id="UDP">UDP</h4>
<p><img src="/2023/05/28/USTC-Computer-Networking-Chapter3/u1.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>UDP数据报格式<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/u2.png" alt></p>
</li>
<li class="lvl-2">
<p>UDP校验和<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/u3.png" alt></p>
</li>
</ul>
<h4 id="RDT可靠数据传输">RDT可靠数据传输</h4>
<h5 id="停止等待协议">停止等待协议</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>rdt1.0</p>
</li>
<li class="lvl-2">
<p>rdt2.0 2.1 2.2</p>
</li>
<li class="lvl-2">
<p>rdt3.0</p>
</li>
</ul>
<h5 id="流水线协议">流水线协议</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>通用的滑动窗口协议<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/sw1.png" alt></p>
</li>
<li class="lvl-2">
<p>GBN和SR<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/sw2.png" alt></p>
</li>
</ul>
<h4 id="TCP">TCP</h4>
<p><img src="/2023/05/28/USTC-Computer-Networking-Chapter3/t1.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>TCP报文段格式<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/t2.png" alt></p>
</li>
<li class="lvl-2">
<p>TCP序号、确认号<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/t3.png" alt><br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/t4.png" alt></p>
</li>
<li class="lvl-2">
<p>rdt<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/t5.png" alt><br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/t6.png" alt></p>
</li>
<li class="lvl-2">
<p>流量控制<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/t7.png" alt></p>
</li>
<li class="lvl-2">
<p>连接管理</p>
<ul class="lvl-2">
<li class="lvl-4">三次握手<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/hand1.png" alt></li>
<li class="lvl-4">四次挥手对称解除连接<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/hand2.png" alt></li>
</ul>
</li>
</ul>
<h4 id="拥塞控制">拥塞控制</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>端到端拥塞控制</p>
</li>
<li class="lvl-2">
<p>网络信息辅助拥塞控制</p>
</li>
</ul>
<h4 id="TCP拥塞控制">TCP拥塞控制</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>TCP采用端到端的拥塞控制</p>
</li>
<li class="lvl-2">
<p>慢启动<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/c1.png" alt><br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/c2.png" alt></p>
</li>
<li class="lvl-2">
<p>AIMD<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/c3.png" alt><br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter3/c4.png" alt></p>
</li>
<li class="lvl-2">
<p>TCP具有公平性，大致为每个TCP连接平分带宽</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>USTC Computer Networking Chapter2</title>
    <url>/2023/05/28/USTC-Computer-Networking-Chapter2/</url>
    <content><![CDATA[<h3 id="第二章-应用层">第二章 应用层</h3>
<h4 id="应用层原理">应用层原理</h4>
<ul class="lvl-0">
<li class="lvl-2">常见架构
<ul class="lvl-2">
<li class="lvl-4">客户-服务器模式（C/S:client/server）</li>
<li class="lvl-4">对等模式(P2P:Peer To Peer)</li>
<li class="lvl-4">混合体：客户-服务器和对等体系结构</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ul class="lvl-0">
<li class="lvl-2">流行的应用层协议
<ul class="lvl-2">
<li class="lvl-4">HTTP</li>
<li class="lvl-4">FTP</li>
<li class="lvl-4">SMTP/POP3/IMAP</li>
<li class="lvl-4">DNS</li>
</ul>
</li>
<li class="lvl-2">进程编址
<ul class="lvl-2">
<li class="lvl-4">主机：唯一的 32位IP地址</li>
<li class="lvl-4">仅仅有IP地址不能够唯一标示一个进程；在一台端系统上有很多应用进程在运行</li>
<li class="lvl-4">所采用的传输层协议：TCP or UDP</li>
<li class="lvl-4">端口号（Port Numbers）16位</li>
<li class="lvl-4">一些知名端口号的例子：HTTP: TCP 80 Mail: TCP25 ftp:TCP 2</li>
</ul>
</li>
<li class="lvl-2">TCP socket
<ul class="lvl-2">
<li class="lvl-4">对于使用面向连接服务（TCP）的应用而言，套接字是4元组的一个具有本地意义的标示</li>
<li class="lvl-4">4元组：(源IP，源port，目标IP，目标port)</li>
<li class="lvl-4">唯一的指定了一个会话（2个进程之间的会话关系）</li>
<li class="lvl-4">应用使用这个标识，与远程的应用进程通信</li>
</ul>
</li>
<li class="lvl-2">UDP socket
<ul class="lvl-2">
<li class="lvl-4">对于使用无连接服务（UDP）的应用而言，套接字是2元组的一个具有本地意义的标示</li>
<li class="lvl-4">2元组：IP，port （源端指定）</li>
<li class="lvl-4">UDP套接字指定了应用所在的一个端节点（end point）</li>
<li class="lvl-4">在发送数据报时，采用创建好的本地套接字（标示ID），就不必在发送每个报文中指明自己所采用的ip和port</li>
<li class="lvl-4">但是在发送报文时，必须要指定对方的ip和udp port(另外一个段节点)</li>
</ul>
</li>
<li class="lvl-2">安全TCP -&gt; SSL
<ul class="lvl-2">
<li class="lvl-4">在TCP上面实现，提供加密的TCP连接,一般归类于应用层</li>
<li class="lvl-4">私密性</li>
<li class="lvl-4">数据完整性</li>
<li class="lvl-4">端到端的鉴别</li>
<li class="lvl-4">https = http + SSL</li>
</ul>
</li>
</ul>
<h4 id="Web-与-HTTP">Web 与 HTTP</h4>
<ul class="lvl-0">
<li class="lvl-2">Web<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/h1.png" alt></li>
<li class="lvl-2">http<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/h2.png" alt><br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/h3.png" alt><br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/h4.png" alt></li>
<li class="lvl-2">http报文<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/h5.png" alt><br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/h6.png" alt><br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/h7.png" alt></li>
<li class="lvl-2">往返时间RTT（round-trip time）：一个小的分组从客户端到服务器，在回到客户端的时间（传输时间忽略）</li>
<li class="lvl-2">Cookies<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/c1.png" alt></li>
<li class="lvl-2">Web缓存（代理服务器proxy）<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/w1.png" alt></li>
<li class="lvl-2">为解决代理服务器网页过时的问题<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/w2.png" alt></li>
</ul>
<h4 id="FTP">FTP</h4>
<p><img src="/2023/05/28/USTC-Computer-Networking-Chapter2/f1.png" alt></p>
<h4 id="EMail">EMail</h4>
<p><img src="/2023/05/28/USTC-Computer-Networking-Chapter2/e1.png" alt><br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/e2.png" alt></p>
<h4 id="DNS">DNS</h4>
<ul class="lvl-0">
<li class="lvl-2">DNS的空间划分是逻辑的，而不是物理的，同一空间的域名可以在不同物理空间中</li>
<li class="lvl-2">域名结构<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/d1.png" alt></li>
<li class="lvl-2">权威DNS服务器<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/d2.png" alt></li>
<li class="lvl-2">TLD服务器<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/d3.png" alt></li>
<li class="lvl-2">资源记录<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/d4.png" alt><br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/d5.png" alt><br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/d6.png" alt></li>
<li class="lvl-2">查询方式：递归、迭代</li>
<li class="lvl-2">DNS报文<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/d7.png" alt></li>
<li class="lvl-2">DNS攻击<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/d8.png" alt></li>
</ul>
<h4 id="P2P">P2P</h4>
<ul class="lvl-0">
<li class="lvl-2">BitTorrent</li>
<li class="lvl-2">Gnutella</li>
<li class="lvl-2">KaZaA</li>
<li class="lvl-2">Distributed Hash Table (DHT)</li>
</ul>
<h4 id="CDN">CDN</h4>
<ul class="lvl-0">
<li class="lvl-2">内容分发网络(Content Delivery Network)</li>
<li class="lvl-2">DASH<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/cdn1.png" alt></li>
<li class="lvl-2">CDN<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/cdn2.png" alt></li>
<li class="lvl-2">Netflix购买亚马逊服务器实现高速的视频流化服务</li>
<li class="lvl-2">互联网的角色
<ul class="lvl-2">
<li class="lvl-4">用户</li>
<li class="lvl-4">ISP</li>
<li class="lvl-4">ICP</li>
<li class="lvl-4">CDN提供商</li>
</ul>
</li>
</ul>
<h4 id="TCP-Socket编程">TCP Socket编程</h4>
<ul class="lvl-0">
<li class="lvl-2">重要的结构体<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/s1.png" alt></li>
<li class="lvl-2">从上到下分别是地址簇、端口号、ip地址、对齐<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/s2.png" alt></li>
<li class="lvl-2">TCP交互模式<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/s3.png" alt></li>
<li class="lvl-2">C客户端（TCP）</li>
</ul>
<figure class="highlight c"><figcaption><span>client.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address of server */</span> </span><br><span class="line">    <span class="type">int</span> clientSocket; <span class="comment">/* socket descriptor */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span> </span><br><span class="line">    <span class="type">char</span> Sentence[<span class="number">128</span>]; </span><br><span class="line">    <span class="type">char</span> modifiedSentence[<span class="number">128</span>]; </span><br><span class="line">    host = argv[<span class="number">1</span>]; port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    clientSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span> </span><br><span class="line">    sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span> </span><br><span class="line">    sad.sin_port = htons((u_short)port); </span><br><span class="line">    ptrh = gethostbyname(host); </span><br><span class="line">    <span class="comment">/* Convert host name to IP address */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sad.sin_addr, ptrh-&gt;h_addr, ptrh-&gt;hlength); </span><br><span class="line">    <span class="comment">//将IP地址拷贝到sad.sin_addr</span></span><br><span class="line">    connect(clientSocket, (<span class="keyword">struct</span> sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    gets(Sentence);</span><br><span class="line">    n=write(clientSocket, Sentence, <span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>); </span><br><span class="line">    n=read(clientSocket, modifiedSentence, <span class="keyword">sizeof</span>(modifiedSentence));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FROM SERVER: %s\n&quot;</span>,modifiedSentence); </span><br><span class="line">    close(clientSocket); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">C服务器（TCP）</li>
</ul>
<figure class="highlight c"><figcaption><span>server.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address of server*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span> <span class="comment">/*client */</span></span><br><span class="line">    <span class="type">int</span> welcomeSocket, connectionSocket; <span class="comment">/* socket descriptor */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span> </span><br><span class="line">    <span class="type">char</span> clientSentence[<span class="number">128</span>]; </span><br><span class="line">    <span class="type">char</span> capitalizedSentence[<span class="number">128</span>]; </span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    welcomeSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span> </span><br><span class="line">    sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span> </span><br><span class="line">    sad.sin_addr.s_addr = INADDR_ANY; <span class="comment">/* set the local IP address */</span> </span><br><span class="line">    sad.sin_port = htons((u_short)port);<span class="comment">/* set the port number */</span> </span><br><span class="line">    bind(welcomeSocket, (<span class="keyword">struct</span> sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    <span class="comment">/* Specify the maximum number of clients that can be queued */</span></span><br><span class="line">    listen(welcomeSocket, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123; </span><br><span class="line">        connectionSocket=accept(welcomeSocket, (<span class="keyword">struct</span> sockaddr *)&amp;cad, &amp;alen);</span><br><span class="line">        n=read(connectionSocket, clientSentence, <span class="keyword">sizeof</span>(clientSentence));</span><br><span class="line">        <span class="comment">/* capitalize Sentence and store the result in capitalizedSentence*/</span></span><br><span class="line">        n=write(connectionSocket, capitalizedSentence, <span class="built_in">strlen</span>(capitalizedSentence)+<span class="number">1</span>); </span><br><span class="line">        close(connectionSocket); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="UDP-Socket编程">UDP Socket编程</h4>
<ul class="lvl-0">
<li class="lvl-2">UDP交互模式<br>
<img src="/2023/05/28/USTC-Computer-Networking-Chapter2/s4.png" alt></li>
</ul>
<h3 id="习题">习题</h3>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>USTC Computer Networking Chapter1</title>
    <url>/2023/05/25/USTC-Computer-Networking-Chapter1/</url>
    <content><![CDATA[<h3 id="第一章-计算机网络概述">第一章 计算机网络概述</h3>
<h4 id="什么是Internet">什么是Internet</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>Internet是一系列网络的网络</p>
</li>
<li class="lvl-2">
<p>网络是一种拓扑结构，可以用图来表示</p>
<ul class="lvl-2">
<li class="lvl-4">节点分为主机节点和数据交换节点</li>
<li class="lvl-4">边分为接入网链路和主干链路</li>
</ul>
</li>
<li class="lvl-2">
<p>网络还包括不同的协议</p>
</li>
<li class="lvl-2">
<p>主机=端系统（host=end system）</p>
</li>
<li class="lvl-2">
<p>Internet标准</p>
<ul class="lvl-2">
<li class="lvl-4">RFC: Request for comments</li>
<li class="lvl-4">IETF: Internet Engineering Task Force</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h4 id="网络边缘">网络边缘</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>端系统（主机）运行应用程序</p>
</li>
<li class="lvl-2">
<p>客户/服务器模式</p>
</li>
<li class="lvl-2">
<p>对等（peer-peer）模式</p>
</li>
</ul>
<h4 id="网络核心">网络核心</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>网络核心：路由器的网状网络</p>
</li>
<li class="lvl-2">
<p>电路交换：为每个呼叫预留一条专有电路：如电话网</p>
<ul class="lvl-2">
<li class="lvl-4">可采用频分、时分、波分</li>
</ul>
</li>
<li class="lvl-2">
<p>分组交换：将要传送的数据分成一个个分组，Internet的实现是分组交换</p>
</li>
</ul>
<h4 id="ISP">ISP</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>ISP（Internet Service Provider）</p>
</li>
<li class="lvl-2">
<p>中心：第一层ISP（如UUNet, BBN/Genuity, Sprint, AT&amp;T）国家/国际覆盖，速率极高</p>
</li>
<li class="lvl-2">
<p>第二层ISP: 更小些的 (通常是区域性的) ISP</p>
</li>
<li class="lvl-2">
<p>第三层ISP与其他本地ISP<br>
<img src="/2023/05/25/USTC-Computer-Networking-Chapter1/isp.png" alt></p>
</li>
</ul>
<h4 id="分组延时">分组延时</h4>
<ol>
<li class="lvl-3">
<p>节点处理延时:</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-4">
<p>检查bit级差错</p>
</li>
<li class="lvl-4">
<p>检查分组首部和决定将分组导向何处</p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>排队延时: 在输出链路上等待输出的时间</p>
</li>
<li class="lvl-3">
<p>传输延时:</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-5">
<p>R=链路带宽(bps)</p>
</li>
<li class="lvl-4">
<p>L=分组长度(bits)</p>
</li>
<li class="lvl-4">
<p>将分组发送到链路上的时间= L/R</p>
</li>
<li class="lvl-4">
<p>存储转发延时</p>
</li>
</ul>
<ol start="4">
<li class="lvl-3">
<p>传播延时:</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-4">
<p>d = 物理链路的长度</p>
</li>
<li class="lvl-4">
<p>s = 在媒体上的传播速度(~2x108 m/sec)</p>
</li>
<li class="lvl-4">
<p>传播延时 = d/s</p>
</li>
</ul>
<h4 id="吞吐量">吞吐量</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>吞吐量: 在源端和目标端之间传输的速率（数据量/单位时间）</p>
</li>
<li class="lvl-2">
<p>瞬间吞吐量: 在一个时间点的速率</p>
</li>
<li class="lvl-2">
<p>平均吞吐量: 在一个长时间内平均值</p>
</li>
<li class="lvl-2">
<p>瓶颈链路影响端到端吞吐</p>
</li>
</ul>
<h4 id="协议层次及服务模型">协议层次及服务模型</h4>
<h5 id="服务和协议">服务和协议</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>服务与协议的区别</p>
<ul class="lvl-2">
<li class="lvl-4">服务(Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直</li>
<li class="lvl-4">原语(primitive)：如一系列socket函数接口</li>
<li class="lvl-4">协议(protocol) ：对等层实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平</li>
</ul>
</li>
<li class="lvl-2">
<p>服务与协议的联系</p>
<ul class="lvl-2">
<li class="lvl-4">本层协议的实现要靠下层提供的服务来实现</li>
<li class="lvl-4">本层实体通过协议为上层提供更高级的服务</li>
</ul>
</li>
</ul>
<h5 id="数据单元-DU">数据单元(DU)</h5>
<p><img src="/2023/05/25/USTC-Computer-Networking-Chapter1/du.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>不同层的PDU</p>
<ul class="lvl-2">
<li class="lvl-4">应用层：报文 message</li>
<li class="lvl-4">传输层：报文段 segment</li>
<li class="lvl-4">网络层：分组/数据报 packet/datagram</li>
<li class="lvl-4">链路层：帧 frame</li>
<li class="lvl-4">物理层：比特 bit</li>
</ul>
</li>
</ul>
<h5 id="Internet-协议栈">Internet 协议栈</h5>
<p><img src="/2023/05/25/USTC-Computer-Networking-Chapter1/stack.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>应用层: 网络应用</p>
<ul class="lvl-2">
<li class="lvl-4">为人类用户或者其他应用进程提供网络应用服务</li>
<li class="lvl-4">FTP, SMTP, HTTP,DNS</li>
</ul>
</li>
<li class="lvl-2">
<p>传输层: 主机之间的数据传输</p>
<ul class="lvl-2">
<li class="lvl-4">在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠地通信</li>
<li class="lvl-4">TCP, UDP</li>
</ul>
</li>
<li class="lvl-2">
<p>网络层: 为数据报从源到目的选择路由</p>
<ul class="lvl-2">
<li class="lvl-4">主机主机之间的通信，端到端通信，不可靠</li>
<li class="lvl-4">IP, 路由协议</li>
</ul>
</li>
<li class="lvl-2">
<p>链路层: 相邻网络节点间的数据传输</p>
<ul class="lvl-2">
<li class="lvl-4">2个相邻2点的通信，点到点通信，可靠或不可靠</li>
<li class="lvl-4">点对对协议PPP, 802.11(wifi), Ethernet</li>
</ul>
</li>
<li class="lvl-2">
<p>物理层: 在线路上传送bit</p>
</li>
</ul>
<h5 id="封装和解封装">封装和解封装</h5>
<p><img src="/2023/05/25/USTC-Computer-Networking-Chapter1/cap.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>端系统5层解封装</p>
</li>
<li class="lvl-2">
<p>路由器3层解封装</p>
</li>
<li class="lvl-2">
<p>交换机2层解封装</p>
</li>
</ul>
<h4 id="历史">历史</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>Cerf and Kahn 网络互联原则定义了今天的Internet体系结构</p>
<ul class="lvl-2">
<li class="lvl-4">极简、自治</li>
<li class="lvl-4">尽力而为（best effort）服务模型</li>
<li class="lvl-4">无状态的路由器</li>
<li class="lvl-4">分布控制</li>
</ul>
</li>
</ul>
<h3 id="习题">习题</h3>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>USTC Computer Networking: A Top-Down Approach</title>
    <url>/2023/05/23/USTC-Computer-Networking/</url>
    <content><![CDATA[<h3 id="Introduction-16">Introduction</h3>
<p>介绍有关计算机网络的问题</p>
<h3 id="Links-17">Links</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://www.bilibili.com/video/BV1JV411t7ow/">课程视频</a></p>
</li>
<li class="lvl-2">
<p><a href="http://staff.ustc.edu.cn/~qzheng/cn.zip">课件</a></p>
</li>
<li class="lvl-2">
<p>课程教材：计算机网络自顶向下方法</p>
</li>
</ul>
<span id="more"></span>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust</title>
    <url>/2023/05/18/Rust/</url>
    <content><![CDATA[<h3 id="Introduction-14">Introduction</h3>
<p>Rust是注重于安全的一门语言，其特色是没有Garbage Collector和无需手动内存管理，广泛运用于系统设计项目中。</p>
<h3 id="编译过程">编译过程</h3>
<h3 id="Cargo">Cargo</h3>
<p>Cargo是Rust的包管理工具</p>
<h3 id="Links-14">Links</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://course.rs/about-book.html">Rust Course</a></p>
</li>
<li class="lvl-2">
<p><a href="https://zh.practice.rs/">Rust by practice</a></p>
</li>
</ul>
<span id="more"></span><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Language</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>CS162 Lecture 5: Device Drivers, Sockets, and IPC (Finished), Concurrency (Processes and Threads)</title>
    <url>/2023/05/17/CS162-Lecture-5/</url>
    <content><![CDATA[<span id="more"></span>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>CS162 Lecture 4: Fork, Introduction to I/O</title>
    <url>/2023/05/17/CS162-Lecture-4/</url>
    <content><![CDATA[<h3 id="pthread">pthread</h3>
<ul class="lvl-0">
<li class="lvl-2">pthread library: POSIX thread library</li>
<li class="lvl-2"><strong>POSIX</strong>: <strong>P</strong>ortable <strong>O</strong>perating <strong>S</strong>ystem <strong>I</strong>nterface(for uni<strong>X</strong>?)</li>
<li class="lvl-2">一个重要的观点是,Every is a “File”</li>
</ul>
<span id="more"></span>
<h3 id="File-System-2">File System</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>File</p>
<ul class="lvl-2">
<li class="lvl-4">是文件系统中被命名的数据</li>
<li class="lvl-4">可以是文本，二进制数据</li>
<li class="lvl-4">Metadata是文件的信息，包括size，Modification time，owner security info，access control</li>
</ul>
</li>
<li class="lvl-2">
<p>Directory</p>
<ul class="lvl-2">
<li class="lvl-4">包含文件和目录的“文件夹”</li>
</ul>
</li>
</ul>
<h3 id="I-O-and-Storage-Layers">I/O and Storage Layers</h3>
<p><img src="/2023/05/17/CS162-Lecture-4/layer.png" alt></p>
<h3 id="C-High-Level-File-API-Streams">C High-Level File API - Streams</h3>
<p><img src="/2023/05/17/CS162-Lecture-4/str.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>文件高层次的抽象是输入输出流，流被认为是字节序列</p>
</li>
</ul>
<h3 id="C-Low-Level-File-File-Descriptors">C Low-Level File - File Descriptors</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Unix I/O的设计理念是</p>
<ul class="lvl-2">
<li class="lvl-4">任何东西都是文件</li>
<li class="lvl-4">使用前open</li>
<li class="lvl-4">以字节为单位</li>
<li class="lvl-4">在kernel中的buffer读写</li>
</ul>
</li>
<li class="lvl-2">
<p>直接使用系统调用实现，而stream是将系统调用read等打包成fread等</p>
</li>
<li class="lvl-2">
<p>从加速操作系统的方面来看，应当尽可能少地使用开销巨大的系统调用，如getpid的user版本比kernel版本快了25倍</p>
</li>
</ul>
<h3 id="Process-and-File">Process and File</h3>
<p><img src="/2023/05/17/CS162-Lecture-4/pf1.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>fork后的子进程复制了父进程的文件描述符表<br>
<img src="/2023/05/17/CS162-Lecture-4/pf2.png" alt></p>
</li>
<li class="lvl-2">
<p>因此当shell fork一个新进程时，标准输入0，标准输出1，标准错误2都会被复制到子进程中，在一个进程中关闭文件只会改变这个进程的文件描述符表</p>
</li>
<li class="lvl-2">
<p>dup用于复制文件描述符</p>
</li>
<li class="lvl-2">
<p>在含有多个线程的进程中fork，子进程只会含有一个线程，也就是调用fork的那个进程</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2023/05/12/Docker/</url>
    <content><![CDATA[<h2 id="Introduction-5">Introduction</h2>
<ul class="lvl-0">
<li class="lvl-2">Docker是一个轻量级的虚拟机管理工具，可以用于搭建环境，分发项目等等。</li>
<li class="lvl-2">它的结构如下图右所示<br>
<img src="/2023/05/12/Docker/vm.png" alt></li>
</ul>
<span id="more"></span>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Tools</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>C</title>
    <url>/2023/05/12/C/</url>
    <content><![CDATA[<h3 id="Introduction-2">Introduction</h3>
<p>C是一种面向过程的编程语言</p>
<span id="more"></span>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Language</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>CS162 Lecture 3: Processes, System Calls, and Fork</title>
    <url>/2023/05/11/CS162-Lecture-3/</url>
    <content><![CDATA[<h3 id="Process">Process</h3>
<ul class="lvl-0">
<li class="lvl-2">PCB<br>
<img src="/2023/05/11/CS162-Lecture-3/pcb.png" alt></li>
</ul>
<span id="more"></span>
<ul class="lvl-0">
<li class="lvl-2">process control block保存了进程的各种信息，调度器维护了这个数据结构</li>
<li class="lvl-2">switch<br>
<img src="/2023/05/11/CS162-Lecture-3/sw.png" alt></li>
</ul>
<h3 id="System-Call">System Call</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>系统调用是用户内核跳转的一种方式，连接了用户空间和内核空间<br>
<img src="/2023/05/11/CS162-Lecture-3/sys.png" alt></p>
</li>
</ul>
<h3 id="fork">fork</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>OS提供了不同的系统调用接口来处理进程，如fork，但是用户使用的是被打包后的系统调用</p>
</li>
<li class="lvl-2">
<p>process api<br>
<img src="/2023/05/11/CS162-Lecture-3/papi.png" alt></p>
</li>
<li class="lvl-2">
<p>fork<br>
<img src="/2023/05/11/CS162-Lecture-3/fork.png" alt></p>
</li>
</ul>
<h3 id="Thread-2">Thread</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>posix pthread是一种行业标准，其致力于提供一个在不同操作系统中适用的半标准的线程接口</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>CS162 Lecture 2: Four Fundamental Concepts of Operating Systems</title>
    <url>/2023/05/10/CS162-Lecture-2/</url>
    <content><![CDATA[<h3 id="4-Concepts">4 Concepts</h3>
<p><img src="/2023/05/10/CS162-Lecture-2/f.png" alt></p>
<span id="more"></span>
<h3 id="Thread-3">Thread</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>独立执行的上下文单元</p>
</li>
<li class="lvl-2">
<p>一个线程被认为是一个虚拟的cpu核心</p>
</li>
<li class="lvl-2">
<p>拥有自己的PC，register，stack，</p>
</li>
<li class="lvl-2">
<p>当一个线程被执行是指处理器核心维护了这个线程有关的寄存器</p>
</li>
<li class="lvl-2">
<p>当一个线程被挂起是指这个线程有关的上下文被保存在内存中，处理器核心在执行其他线程</p>
</li>
<li class="lvl-2">
<p>一个线程要么运行在cpu核心上，要么被保存在Thread Control Block(TCB)中</p>
</li>
</ul>
<h3 id="Address-Space">Address Space</h3>
<p><img src="/2023/05/10/CS162-Lecture-2/add.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>也被叫做Virtual Address Space，是操作系统提供给进程的虚拟地址空间</p>
</li>
<li class="lvl-2">
<p>地址空间是一系列地址以及和地址有关的状态</p>
</li>
<li class="lvl-2">
<p>32bit和64bit处理器拥有的地址空间是不一样的</p>
</li>
</ul>
<h3 id="Process-2">Process</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>有隔离性的运行环境</p>
</li>
<li class="lvl-2">
<p>拥有自己的内存（address space）和文件描述符，文件系统上下文</p>
</li>
<li class="lvl-2">
<p>一个进程可以有多个线程</p>
</li>
<li class="lvl-2">
<p>进程里交流是容易的，进程间交流时困难的<br>
<img src="/2023/05/10/CS162-Lecture-2/smp.png" alt></p>
</li>
</ul>
<h3 id="Dual-mode-operation-Protection">Dual mode operation / Protection</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>硬件至少提供了两个mode，kernel和user，两者拥有不同的硬件权限</p>
</li>
<li class="lvl-2">
<p>通过不同的mode可以实现操作系统内核空间和用户空间的切换，内核空间和用户空间是一个抽象的概念，而内核模式和用户模式是机器拥有的模式。</p>
</li>
<li class="lvl-2">
<p>三种从用户空间进入内核空间的方式<br>
<img src="/2023/05/10/CS162-Lecture-2/3t.png" alt></p>
</li>
<li class="lvl-2">
<p>Unix的架构<br>
<img src="/2023/05/10/CS162-Lecture-2/unix.png" alt></p>
</li>
<li class="lvl-2">
<p>不同于内核空间和用户空间两层，多层的架构实现被称为虚拟机技术<br>
<img src="/2023/05/10/CS162-Lecture-2/vm.png" alt></p>
</li>
<li class="lvl-2">
<p>上图的架构给出了Hypervisor和Docker的模型</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>CS162 HW 1: List</title>
    <url>/2023/05/06/CS162-HW-1/</url>
    <content><![CDATA[<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>CS162 Project 0: Pregame</title>
    <url>/2023/05/06/CS162-Project-0/</url>
    <content><![CDATA[<span id="more"></span><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>CS162 HW 0: Introduction</title>
    <url>/2023/05/06/CS162-HW-0/</url>
    <content><![CDATA[<h3 id="Docker配置环境">Docker配置环境</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://alfredthiel.gitbook.io/pintosbook/">教程</a></li>
<li class="lvl-2">也可以参考课程网站配置VirtualBox，但我的机子跑不出来😭</li>
</ul>
<h3 id="Docker目录挂载">Docker目录挂载</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>获取实验仓库</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:Berkeley-CS162/student0.git</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>目录挂载</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --rm --name pintos --mount type=bind,source=/home/huayi/student0,target=/home/PKUOS/pintos pkuflyingpig/pintos bash</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>可以让主机和docker镜像共用目录</p>
</li>
</ul>
<h3 id="Tools">Tools</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>老生常谈的几个工具了</p>
</li>
</ul>
<h3 id="exercise">exercise</h3>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>CS162 Lecture 1: Intro to CS162: What is an operating system?</title>
    <url>/2023/05/06/CS162-Lecture-1/</url>
    <content><![CDATA[<h3 id="软硬件接口">软硬件接口</h3>
<p><img src="/2023/05/06/CS162-Lecture-1/hs.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">在CS61C中我们已经学习过机器架构，操作系统的一大目的是，为应用程序抽象硬件的细节，而只提供特定功能的接口。</li>
</ul>
<span id="more"></span>
<h3 id="OS概览">OS概览</h3>
<p><img src="/2023/05/06/CS162-Lecture-1/basic.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>操作系统将硬件分别抽象成进程中的各个部分，进程就是操作系统提供的一个编程抽象，应用程序眼中的“机器”就是被抽象后的硬件——进程。</p>
</li>
</ul>
<h3 id="进程切换">进程切换</h3>
<p><img src="/2023/05/06/CS162-Lecture-1/sw.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>操作系统可以在不同进程中切换，由于时间很短，这造成了不同进程同时运行的假象。</p>
</li>
<li class="lvl-2">
<p>操作系统在不同进程中提供隔离性，用户进程不能访问属于内核的进程空间，否则触发Segmentation fault</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>UCB CS162: Operating Systems and Systems Programming</title>
    <url>/2023/05/03/UCB-CS162/</url>
    <content><![CDATA[<h3 id="Course-About-7">Course About</h3>
<p>介绍有关操作系统的问题</p>
<h3 id="Links-16">Links</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://cs162.org/">课程主页</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.bilibili.com/video/BV1ab4y1b7BU">课程视频</a></p>
</li>
<li class="lvl-2">
<p><a href="https://benpfaff.org/papers/pintos.pdf">Pintos</a></p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab thread</title>
    <url>/2023/05/03/6-S081-Lab-thread/</url>
    <content><![CDATA[<h3 id="Compulsory-exercises-4">Compulsory exercises</h3>
<h4 id="Preparation-4">Preparation</h4>
<ul class="lvl-0">
<li class="lvl-2">reading<br>
<img src="/2023/05/03/6-S081-Lab-thread/pre.png" alt><br>
To start the lab, switch to the thread branch:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git checkout thread</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="Uthread-switching-between-threads-moderate">Uthread: switching between threads (moderate)</h4>
<h4 id="Using-threads-moderate">Using threads (moderate)</h4>
<h4 id="Barrier-moderate">Barrier(moderate)</h4>
<h3 id="Optional-challenge-exercises-4">Optional challenge exercises</h3>
<p>The user-level thread package interacts badly with the operating system in several ways. For example, if one user-level thread blocks in a system call, another user-level thread won’t run, because the user-level threads scheduler doesn’t know that one of its threads has been descheduled by the xv6 scheduler. As another example, two user-level threads will not run concurrently on different cores, because the xv6 scheduler isn’t aware that there are multiple threads that could run in parallel. Note that if two user-level threads were to run truly in parallel, this implementation won’t work because of several races (e.g., two threads on different processors could call thread_schedule concurrently, select the same runnable thread, and both run it on different processors.)</p>
<p>There are several ways of addressing these problems. One is using scheduler activations and another is to use one kernel thread per user-level thread (as Linux kernels do). Implement one of these ways in xv6. This is not easy to get right; for example, you will need to implement TLB shootdown when updating a page table for a multithreaded user process.</p>
<p>Add locks, condition variables, barriers, etc. to your thread package.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 17: Virtual memory for applications</title>
    <url>/2023/04/28/6-S081-Lecture-17/</url>
    <content><![CDATA[<h3 id="Reading-8">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/readings/appel-li.pdf">Read Virtual Memory Primitives for User Programs (1991)</a></li>
</ul>
<span id="more"></span>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>Hung-yi Lee ML Lecture1: Introduction of Deep Learning</title>
    <url>/2023/04/26/Hung-yi-Lee-ML-Lecture1/</url>
    <content><![CDATA[<h3 id="机器学习">机器学习</h3>
<ul class="lvl-0">
<li class="lvl-2">机器学习在教授的讲述中被描述为让机器找到一个函数f()，这个函数可以很复杂，但是可以解决许多问题，建立函数原型的过程叫做建立模型，根据函数的好坏进行不断优化的过程叫做训练，这个过程很像人类不断试错找寻更好的解决方案的过程，就像机器在学习一样。</li>
<li class="lvl-2">机器学习的一般步骤是
<ul class="lvl-2">
<li class="lvl-4">建立模型：建立含有未知参数的函数</li>
<li class="lvl-4">定义loss函数L()</li>
<li class="lvl-4">优化：找到使L()最小的未知参数，一般使用梯度下降法</li>
</ul>
</li>
<li class="lvl-2">一般来说，使用类神经网络建立函数模型，通过叠加神经网络的层数，来达到更高的测试正确率，这样的方法被称为深度学习，深度学习是机器学习中使用最广泛也最重要的方法之一。</li>
<li class="lvl-2">过拟合Overfitting指的是，训练出的模型在训练资料上表现好而在测试集上表现不好。</li>
</ul>
<span id="more"></span>
<h3 id="PyTorch">PyTorch</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>PyTorch是专门用于机器学习的Python库，封装了数据读取、神经网络、激活函数、微分计算梯度下降等机器学习中常用的操作和对象，是广泛使用的机器学习框架。另外，PyTorch还可以使用GPU的并行计算加速Tensor的计算，使训练效率加快。</p>
</li>
</ul>
<h3 id="Colab">Colab</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Colab是谷歌名下类似于jupyter的网页Python应用程序，不仅可以运行Python，提供存储空间，还可以使用云端的计算资源来进行模型训练</p>
</li>
<li class="lvl-2">
<p><code>!nvidia-smi</code>查看获取的GPU计算资源</p>
</li>
</ul>
<h3 id="HW1-Regression">HW1 Regression</h3>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hung-yi Lee Machine Learning</title>
    <url>/2023/04/26/Hung-yi-Lee-Machine-Learning/</url>
    <content><![CDATA[<h3 id="Course-About-3">Course About</h3>
<p>介绍有关机器学习的问题。</p>
<h3 id="Links-7">Links</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://speech.ee.ntu.edu.tw/~hylee/ml/2022-spring.php">课程主页</a></p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/2023/04/25/Java/</url>
    <content><![CDATA[<h3 id="Introduction-7">Introduction</h3>
<p>Java是一种面向对象的编程语言，JVM虚拟机的使用，让java的编译过程十分特殊，接口的引入，也让面向对象的特征十分突出。</p>
<span id="more"></span>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Language</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2023/04/25/Python/</url>
    <content><![CDATA[<h3 id="Introduction">Introduction</h3>
<p>Python是一种面向对象的编程语言，不同于C和C++，它是一种解释型语言。</p>
<span id="more"></span>
<h3 id="jupyter">jupyter</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Language</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>How to start a Project using C</title>
    <url>/2023/04/25/Zero-C-Project/</url>
    <content><![CDATA[<h3 id="介绍">介绍</h3>
<ul class="lvl-0">
<li class="lvl-2">将会介绍如何使用C开发在Linux平台上运行的控制台应用程序</li>
<li class="lvl-2">和HelloWorld一样😄</li>
<li class="lvl-2">选用的项目是<a href="https://viewsourcecode.org/snaptoken/kilo/">自己写一个文本编辑器！(Build Your Own Text Editor)</a></li>
<li class="lvl-2">初步开发这个项目，我觉得从中学到最重要的东西就是，开发不是一蹴而就的，为了更新功能，删改重构是常有的事情，现在这个阶段，很难有一次性铺平，统筹规划好所有东西的能力，所以不能用十分平面的想法去开发。当然这一切要尽可能与其他模块解耦，不能因为这里的重构，影响到其他大的模块。</li>
</ul>
<span id="more"></span>
<h3 id="准备工作">准备工作</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>了解所要开发项目的背景知识</p>
</li>
</ul>
<h3 id="环境搭建">环境搭建</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>gcc作为编译器工具链</p>
</li>
<li class="lvl-2">
<p>Make作为构建工具</p>
</li>
</ul>
<h3 id="项目框架">项目框架</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>一个kilo.c文件，但划分模块</p>
</li>
</ul>
<h3 id="开发与测试">开发与测试</h3>
<h3 id="运行维护">运行维护</h3>
<p>updating…</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Project</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>0-&gt;1</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>x86</title>
    <url>/2023/04/24/x86/</url>
    <content><![CDATA[<h3 id="Introduction-19">Introduction</h3>
<p>x86是一种复杂指令集架构的汇编语言</p>
<span id="more"></span><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Language</category>
      </categories>
      <tags>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>How to start a Project from Zero</title>
    <url>/2023/04/24/Zero-Project/</url>
    <content><![CDATA[<h3 id="介绍-2">介绍</h3>
<ul class="lvl-0">
<li class="lvl-2">如何从0开始完成一个项目？这是我在学习过程中遇到的一个难以忽视的问题。这篇文章将会包含如何去开始一个项目，如何去维护一个项目的记录。不过这些想法没有经过认证，仅仅是对于开发过程中的思考方式的归纳和总结。</li>
<li class="lvl-2">开发的范式很难总结出来，因此我将尝试分析我在一门程序设计专题课最后的大作业开发流程，通过完善这个远古项目开发的过程，来帮助构建一个开发的范式。</li>
<li class="lvl-2">这个项目采用C和visual studio2017开发</li>
</ul>
<span id="more"></span>
<h3 id="项目介绍">项目介绍</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>项目的名字叫做&quot;排序可视化&quot;，要求我们小组实现常见排序的可视化展示。</p>
</li>
<li class="lvl-2">
<p>项目的实现需要借助学校里一个老掉牙的图形库，该图形库为我们封装了某些图形的画法，还有windows窗口的生成等等</p>
</li>
<li class="lvl-2">
<p>这个项目按理来说是简单的，但是还是有一些刚开始难以思考的要素，比如说Windows，比如说图形化，这样就不够把最需要关注的点显露出来，因此我想在另一篇文章中选择一个要素最为稀少的项目，也就是使用C/C++和文本编辑器开发的在Linux平台上运行的控制台应用程序，来阐述我认为的项目开发思路。</p>
</li>
</ul>
<h3 id="准备工作-2">准备工作</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>单拎出来一个排序可视化，我们如何使用我们手上零散的开发经验和工具，将这个项目有序地进行下去呢？这是一个很重要的问题，大家都没有开发经验，大家都是小白，但我们却要去完成一个&quot;黑箱&quot;，而这个黑箱居然能够实现排序可视化的功能，我们很兴奋，但是也不知道从何开始。</p>
</li>
<li class="lvl-2">
<p>作为组长，我说了句令人信服的废话：大家去学习一下什么是排序。于是我们组员花了一周时间学会了冒泡选择插入归并等排序算法。</p>
</li>
<li class="lvl-2">
<p>我又说，要用学校里这个很烂的图形库，大家把画图的函数都看看，熟悉一下图形库。于是组员们又花了一周时间，把这个老古董啃了一遍。</p>
</li>
<li class="lvl-2">
<p>但是怎么开始呢？我们回去个人单干了一星期，在我偷懒的时间里，有组员的排序可视化已经初具雏形，我很高兴，遂召集大家开会，商量如何在这个雏形上完成我们的项目，但是一开会我们发现了一个问题，程序在main.c里面，要分模块很难，这对后来的模块划分还有模块添加造成了麻烦。</p>
</li>
<li class="lvl-2">
<p>于是我尝试去划分模块，但是没能成功，于是这次我从头文件的建立开始，自己写了一大堆代码，但是每个模块都分成小块放在一个文件里，把每个功能模块划分好，最后也完成了一个雏形，收获了组员们的一致好评。</p>
</li>
<li class="lvl-2">
<p>这是我们在毫无经验的情况下摸索出来的准备工作过程，其中不乏有些不成熟的地方，但是可取之处也是不少，下面是我后来的一些反思和经验。</p>
</li>
</ul>
<h4 id="我们的项目是什么"><mark>我们的项目是什么</mark></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>这是一个我当时从未思考过的问题，后来我觉得这是十分重要的，明白一个项目是什么，是避免成为无头苍蝇的第一步。</p>
</li>
<li class="lvl-2">
<p>我们的项目是一个借用第三方图形库，使用C语言和visual studio2017开发的在windows平台上运行的图形化应用程序。</p>
</li>
<li class="lvl-2">
<p>这句话的含义现在看来十分丰富</p>
</li>
</ul>
<h5 id="编程语言"><mark>编程语言</mark></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>编程语言的选择有很多，比如C、C++、Python、Java、Rust等等</p>
</li>
<li class="lvl-2">
<p>编程语言应当发挥它的长处，为项目提供开发效率的提升、安全性的提高、可读性的增强、运行速度的提升这些好处</p>
</li>
<li class="lvl-2">
<p>由于课程要求，本项目只能使用C开发</p>
</li>
</ul>
<h5 id="IDE"><mark>IDE</mark></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>集成开发环境（IDE）为我们省略了大量环境搭建的过程，极高地提升了开发速度，但是我们是需要对项目的编译、调试过程有所了解的，这也又助于我们更好地使用IDE，环境搭建的具体过程将在后文叙述</p>
</li>
<li class="lvl-2">
<p>IDE的选择很多，有VS，CLion，IDEA，Pycharm等</p>
</li>
<li class="lvl-2">
<p>要想了解IDE的环境搭建过程，必须对特定语言的特性和编译（解释）方式十分了解</p>
</li>
</ul>
<h5 id="运行环境"><mark>运行环境</mark></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>运行环境在我的理解下应该指的就是操作系统，应用程序使用操作系统提供的API和文件系统等，程序应当保证对特定操作系统的兼容性</p>
</li>
<li class="lvl-2">
<p>有一个例外是操作系统的编写，操作系统的内核本身应当是机器有关的，可以认为，操作系统内核由机器架构提供环境，而应用程序由操作系统提供环境</p>
</li>
</ul>
<h5 id="程序类型"><mark>程序类型</mark></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>本项目的类型是图形化应用程序</p>
</li>
<li class="lvl-2">
<p>Windows上的程序类型应该还有控制台应用程序等，更多的细节需要对Windows更加了解</p>
</li>
</ul>
<h4 id="相关背景知识"><mark>相关背景知识</mark></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>由于很难一开始就对某个领域的细枝末节了解的十分清晰，在面对一个新项目时，我们需要获取项目相关的背景知识</p>
</li>
<li class="lvl-2">
<p>比如说这个项目有关排序和可视化，我们就要去了解排序相关的知识和图形库相关的知识</p>
</li>
<li class="lvl-2">
<p>如果这个项目有关操作系统，那么我们就要去获取操作系统的设计和机器架构相关的背景知识</p>
</li>
<li class="lvl-2">
<p>甚至当你在开发过程中也会遇到语言语法的卡壳，这时候一份C语言参考文档就十分重要</p>
</li>
<li class="lvl-2">
<p>可以自己整理一套自己的常用开发参考，在必要时使用stackoverflow或者是ChatGPT</p>
</li>
</ul>
<h3 id="项目大纲">项目大纲</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>后面我又说，过几天开个会，把项目的模块分一下，前面的指挥调度已经建立了我组长的威信，组员们纷纷相信我的胡言乱语，于是我们花了一个下午的时间，给项目弄了个思维导图。<br>
<img src="/2023/04/24/Zero-Project/sort.png" alt></p>
</li>
<li class="lvl-2">
<p>项目的大纲是重要的，因为各种模块的解耦是如此地困难，从刚开始就有一个大体的框架和划分模块的意识是必要的</p>
</li>
</ul>
<h4 id="大纲成为框架"><mark>大纲成为框架</mark></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>大纲的代码化就是项目框架，如何编写一个好的框架至关重要，但是我也不会。根据我的经验来说，框架要满足的要求是，划分好独立的模块，能够提供添加模块的接口和去除模块的方法。</p>
</li>
<li class="lvl-2">
<p>项目框架不是完美的，好的框架可以一定程度上减少解耦的工作量，但是解耦在项目开发的过程中仍然是必不可少的。</p>
</li>
<li class="lvl-2">
<p>仅仅在这个项目中，我觉得框架就是写好各个模块的头文件，然后以main.c开始，用树形结构确定每个模块的依赖关系，再写好相应源代码的头文件调用。相互独立的模块或者相互传递数据的模块表现为同一辈分，而依赖于子模块功能的模块则表现为父节点。</p>
</li>
</ul>
<h3 id="环境搭建-2">环境搭建</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>老师直接推荐IDE VS2017开发，我们当时对环境搭建也是一点不懂，IDE很好地处理了这项工作，但是我们在提交时在想，别人怎么看到我们最后展现出来的成果，我们提交的项目只有代码，别人应该怎么运行它。组员甚至问了一个问题，解决方案平台里面的Debug和release是什么意思，x86和x64又是什么意思，我摇摇头，因为我也对此一无所知。</p>
</li>
</ul>
<h4 id="编译器"><mark>编译器</mark></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于C语言的项目来说，掌握CALL的文件编译过程十分重要，分别是编译器把C语言转化为x86的汇编形式，汇编器把汇编形式转换为二进制形式，链接器处理好各对象文件的关系，执行器负责执行程序。</p>
</li>
<li class="lvl-2">
<p>编译过程有很多的编译器软件开发包可以完成，比如说gcc，clang，在win平台还有MinGW，VS2017使用的应该是MSVC工具链，包括常用的编译器和调试器工具</p>
</li>
</ul>
<h4 id="构建工具"><mark>构建工具</mark></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用Make或者CMake，自己使用Make是明白一些IDE大型项目的构建过程的开始，另外多阅读其他项目的Makefile也有助于理解构建过程</p>
</li>
</ul>
<h4 id="环境变量"><mark>环境变量</mark></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>环境变量是操作系统用于控制运行环境的参数</p>
</li>
</ul>
<h3 id="团队开发">团队开发</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>后面我们进入了愉快的写模块环节，期间我们遇到了一个问题，每个人都改代码，怎么一起开发呢，本来组员说用LiveShare，后面没搞成就变成群里发压缩文件了。这样的结果是在同一时间段我们还是只能有一个人修改。所幸最后是成功完成了。</p>
</li>
</ul>
<h4 id="注释"><mark>注释</mark></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>注释和变量命名无论是对单人还是多人开发都是很重要的，写好函数接口的注释无论对其他的贡献者还是后来的你都是大有帮助。</p>
</li>
</ul>
<h4 id="版本控制"><mark>版本控制</mark></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>应该使用git/github多人工作流。</p>
</li>
</ul>
<h4 id="调试"><mark>调试</mark></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>用GDB或者IDE自带的调试器</p>
</li>
</ul>
<h3 id="运行维护-2">运行维护</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>…</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Project</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>0-&gt;1</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab cow</title>
    <url>/2023/04/23/6-S081-Lab-cow/</url>
    <content><![CDATA[<h3 id="Compulsory-exercises">Compulsory exercises</h3>
<h4 id="Preparation">Preparation</h4>
<ul class="lvl-0">
<li class="lvl-2">To start the lab, switch to the cow branch:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git checkout cow</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">OS真不是人写的把😭</li>
</ul>
<span id="more"></span>
<h4 id="Implement-copy-on-write-hard">Implement copy-on write(hard)</h4>
<ul class="lvl-0">
<li class="lvl-2">当xv6 fork一个子进程时，需要复制父进程的地址空间，这不仅占用了空间，也消耗了时间，你的任务是采用写时复制，fork()时child使用parent的内存空间，即子进程映射到父进程的物理空间上，当进程要写时，触发Page Fault</li>
<li class="lvl-2">实现COW<br>
<img src="/2023/04/23/6-S081-Lab-cow/cow.png" alt></li>
<li class="lvl-2">修改uvmcopy()以在fork()时不分配新page，而映射到父进程</li>
</ul>
<figure class="highlight c"><figcaption><span>vm.c uvmcopy()</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;cnt_lock);</span><br><span class="line">    cnt[((uint64)pa) &gt;&gt; <span class="number">12</span>] += <span class="number">1</span>;</span><br><span class="line">    release(&amp;cnt_lock);</span><br><span class="line"></span><br><span class="line">    *pte = *pte &amp; (~PTE_W);</span><br><span class="line">    *pte = *pte | (PTE_RSW);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>修改usertrap()以处理Page Fault</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>trap.c usertrap()</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((r_scause() == <span class="number">15</span>)) &#123;</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="keyword">if</span> (cow(p-&gt;pagetable, va) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>添加PTE_RSW标志位用于标识是否是cow page</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>riscv.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_RSW (1L &lt;&lt; 8)</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>添加cow处理函数</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>vm.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">cow</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (va &gt;= MAXVA) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pte_t</span>* pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_RSW) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_U) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    uint64 pa = PTE2PA(*pte);</span><br><span class="line">    uint64 ka = (uint64) kalloc();</span><br><span class="line">    <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      memmove((<span class="type">char</span>*)ka, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">      uint64 flags = PTE_FLAGS(*pte);</span><br><span class="line">      *pte = PA2PTE(ka) | flags | PTE_W;</span><br><span class="line">      *pte &amp;= (~PTE_RSW);</span><br><span class="line">      kfree((<span class="type">void</span> *)pa);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>修改copyout()</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>vm.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pte_t</span>* pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_W) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cow(pagetable, va0) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pa0 = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>添加计数器和锁，并在每次fork是增加计数，在free时只有计数为0时才能真正free</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>kalloc.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">cnt_lock</span>;</span></span><br><span class="line"><span class="type">int</span> cnt[PHYSTOP &gt;&gt; <span class="number">12</span>];</span><br></pre></td></tr></table></figure>
<h3 id="Optional-challenge-exercises">Optional challenge exercises</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Modify xv6 to support both lazy page allocation and COW.</p>
</li>
<li class="lvl-2">
<p>Measure how much your COW implementation reduces the number of bytes xv6 copies and the number of physical pages it allocates. Find and exploit opportunities to further reduce those numbers.</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 16: File system performance and fast crash recovery</title>
    <url>/2023/04/22/6-S081-Lecture-16/</url>
    <content><![CDATA[<h3 id="Reading-7">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/readings/microkernel.pdf">Read Journaling the Linux ext2fs Filesystem (1998)</a></li>
</ul>
<h3 id="Information-2">Information</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一节OS论文的阅读讲座</p>
</li>
</ul>
<span id="more"></span>
<h3 id="ext3">ext3</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>“log” = journal</p>
</li>
<li class="lvl-2">
<p>ext3 = ext2 + journal</p>
</li>
</ul>
<h3 id="xv6-log-review">xv6 log review</h3>
<h3 id="ext3-log">ext3 log</h3>
<h3 id="ext3-log-format">ext3 log format</h3>
<h3 id="ASYNC">ASYNC</h3>
<h3 id="Batching">Batching</h3>
<h3 id="Concurrency">Concurrency</h3>
<h3 id="ext3-code">ext3 code</h3>
<h3 id="steps-in-commit">steps in commit</h3>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 15: Crash recovery</title>
    <url>/2023/04/22/6-S081-Lecture-15/</url>
    <content><![CDATA[<h3 id="Reading-6">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">Read logging sections of “File system”</a></li>
<li class="lvl-2">read code<br>
<img src="/2023/04/22/6-S081-Lecture-15/read15.png" alt="read"></li>
</ul>
<h3 id="Information">Information</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>最后一节关于xv6的讲座了，后面的重点会放在操作系统论文的阅读上</p>
</li>
<li class="lvl-2">
<p>再见了所有的xv6 😭</p>
</li>
</ul>
<span id="more"></span>
<h3 id="Problem">Problem</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>crash如电源中断，系统重启等</p>
</li>
<li class="lvl-2">
<p>crash会使得建立在磁盘上的文件系统进入不正确的的状态，怎样保证crash后维持正确的状态呢？</p>
</li>
<li class="lvl-2">
<p>解决方案是logging</p>
</li>
</ul>
<h3 id="Risk">Risk</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>文件系统的操作是多步的</p>
</li>
<li class="lvl-2">
<p>如果crash后重启，很可能要么再次crash，要么读写了错误的数据</p>
</li>
</ul>
<h3 id="logging">logging</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>log的步骤<br>
<img src="/2023/04/22/6-S081-Lecture-15/log.png" alt></p>
<ul class="lvl-2">
<li class="lvl-4">log writes</li>
<li class="lvl-4">commit op</li>
<li class="lvl-4">install</li>
<li class="lvl-4">clean log</li>
<li class="lvl-4">log能够保证文件系统操作的原子性，并提供快速恢复的能力，在不同步骤crash都有不同的恢复方案</li>
</ul>
</li>
<li class="lvl-2">
<p>log的内容<br>
<img src="/2023/04/22/6-S081-Lecture-15/log2.png" alt></p>
<ul class="lvl-2">
<li class="lvl-4">内存中有磁盘中log的cache</li>
</ul>
</li>
</ul>
<h3 id="Challenges">Challenges</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>eviction</p>
<ul class="lvl-2">
<li class="lvl-4">不要驱逐正在log的block</li>
</ul>
</li>
<li class="lvl-2">
<p>fs operation must fit log</p>
<ul class="lvl-2">
<li class="lvl-4">log限制了文件系统一次最多只能操作30个block</li>
</ul>
</li>
<li class="lvl-2">
<p>concurrent fs calls</p>
<ul class="lvl-2">
<li class="lvl-4">并行的文件系统操作也要符合上一条log的限制</li>
</ul>
</li>
</ul>
<h3 id="Summary-2">Summary</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>log for multi-step ops</p>
</li>
<li class="lvl-2">
<p>But: performance</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Protocol</title>
    <url>/2023/04/20/Network-Protocol/</url>
    <content><![CDATA[<h3 id="Introduction-11">Introduction</h3>
<p>计算机网络的架构分为很多层，其中主流的分类方法是四层的TCP/IP结构，本文将从这四层结构出发（又是自顶向下😆），介绍属于网络不同层的网络协议。</p>
<span id="more"></span>
<h3 id="Layer">Layer</h3>
<h3 id="应用层">应用层</h3>
<h4 id="HTTP">HTTP</h4>
<h3 id="运输层">运输层</h3>
<h4 id="TCP">TCP</h4>
<h4 id="UDP">UDP</h4>
<h3 id="网络层">网络层</h3>
<h4 id="IP">IP</h4>
<h3 id="链路层">链路层</h3>
<h4 id="Ethernet">Ethernet</h4>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 14: File systems</title>
    <url>/2023/04/20/6-S081-Lecture-14/</url>
    <content><![CDATA[<h3 id="Reading-5">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">Read Chapter8</a></li>
<li class="lvl-2">read code<br>
<img src="/2023/04/20/6-S081-Lecture-14/read14.png" alt="read"></li>
</ul>
<span id="more"></span>
<h3 id="File-System">File System</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>User-friendly names/pathnames</p>
</li>
<li class="lvl-2">
<p>Share files between users/process</p>
</li>
<li class="lvl-2">
<p>Persistence/durability</p>
</li>
</ul>
<h3 id="Why-intersting">Why intersting?</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Abstraction is useful</p>
</li>
<li class="lvl-2">
<p>Crash safety</p>
</li>
<li class="lvl-2">
<p>Disk layout</p>
</li>
<li class="lvl-2">
<p>Performance -&gt; Storage devices are slow -&gt; to be fast</p>
<ul class="lvl-2">
<li class="lvl-4">storage -&gt; buffercache</li>
<li class="lvl-4">device -&gt; concurrency</li>
</ul>
</li>
</ul>
<h3 id="API-example">API example</h3>
<p><img src="/2023/04/20/6-S081-Lecture-14/fs1.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>xv6文件系统提供的API实现了文件系统基本的用户级操作</p>
</li>
</ul>
<h3 id="FS-structure">FS structure</h3>
<p><img src="/2023/04/20/6-S081-Lecture-14/fs2.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>inode含有文件的信息，代表一个独立的文件</p>
</li>
<li class="lvl-2">
<p>inode的大小是64Bytes</p>
</li>
</ul>
<h3 id="FS-Layer">FS Layer</h3>
<p><img src="/2023/04/20/6-S081-Lecture-14/fs3.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>文件系统的多层结构抽象了硬件，并为软件提供了接口</p>
</li>
</ul>
<h3 id="Storage-devices">Storage devices</h3>
<p><img src="/2023/04/20/6-S081-Lecture-14/fs4.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这里需要注意的是sector和block的大小，在xv6中</p>
<ul class="lvl-2">
<li class="lvl-4">sector -&gt; 512Bytes</li>
<li class="lvl-4">block -&gt; 1024Bytes</li>
</ul>
</li>
<li class="lvl-2">
<p>这里有一个问题，block的大小由什么决定，是软件还是硬件，个人认为这里的block是由xv6的设计决定的</p>
</li>
</ul>
<h3 id="Disk-layout">Disk layout</h3>
<p><img src="/2023/04/20/6-S081-Lecture-14/fs5.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这就是文件系统在磁盘上的架构，单位是block(1024B)</p>
</li>
<li class="lvl-2">
<p>block0 -&gt; boot</p>
</li>
<li class="lvl-2">
<p>block1 -&gt; superblocks</p>
</li>
<li class="lvl-2">
<p>block2-31 -&gt; log</p>
</li>
<li class="lvl-2">
<p>block32-44 -&gt; inode</p>
<ul class="lvl-2">
<li class="lvl-4">每个inode 64B</li>
</ul>
</li>
<li class="lvl-2">
<p>block45 -&gt; bitmap</p>
</li>
<li class="lvl-2">
<p>block46-… -&gt; data</p>
</li>
</ul>
<h3 id="On-disk-inode">On-disk inode</h3>
<p><img src="/2023/04/20/6-S081-Lecture-14/fs6.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>inode是一个数据结构，大小64B，包含了文件的基本信息和数据映射</p>
</li>
<li class="lvl-2">
<p>type代表了文件的类型，如文件或目录</p>
</li>
<li class="lvl-2">
<p>nlink</p>
</li>
<li class="lvl-2">
<p>size文件的大小</p>
</li>
<li class="lvl-2">
<p>bn0-bn11 -&gt; direct block number</p>
<ul class="lvl-2">
<li class="lvl-4">每个bn都是4B的地址</li>
<li class="lvl-4">直接映射到12个block的地址</li>
</ul>
</li>
<li class="lvl-2">
<p>bn12 -&gt; indirect block number</p>
<ul class="lvl-2">
<li class="lvl-4">bn12是一个4B的地址</li>
<li class="lvl-4">映射到一个block，这个block包含了256个bn直接映射到256个block</li>
<li class="lvl-4">一个block(1024B)可包含1024B/4B = 256个bn</li>
</ul>
</li>
<li class="lvl-2">
<p>总共的直接映射bn数量12+256 = 268个</p>
</li>
<li class="lvl-2">
<p>文件的最大大小268*1024B = 268KB</p>
</li>
</ul>
<h3 id="Directory">Directory</h3>
<p><img src="/2023/04/20/6-S081-Lecture-14/fs7.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>目录是一个文件，它的data中包含了特殊的数据结构entry(16B)，可以把文件名和文件索引联系起来</p>
</li>
<li class="lvl-2">
<p>“/y/x&quot;中第一个”/&quot;的意思是root inode，其索引为1</p>
</li>
</ul>
<h3 id="Bcache-block-cache">Bcache(block cache)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>one copy of block in memory</p>
</li>
<li class="lvl-2">
<p>sleep locks</p>
</li>
<li class="lvl-2">
<p>LRU</p>
</li>
<li class="lvl-2">
<p>two levels of locking</p>
<ul class="lvl-2">
<li class="lvl-4">protect bcache</li>
<li class="lvl-4">sleep locks</li>
</ul>
</li>
</ul>
<h3 id="Summary">Summary</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>fs = on-disk data structure</p>
</li>
<li class="lvl-2">
<p>block cache</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 13: Q&amp;A labs</title>
    <url>/2023/04/20/6-S081-Lecture-13/</url>
    <content><![CDATA[<h3 id="COW-lab">COW lab</h3>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>Bit operation</title>
    <url>/2023/04/16/Bit-operation/</url>
    <content><![CDATA[<h3 id="基本运算">基本运算</h3>
<p>1.<code>&amp;</code> 运算符</p>
<p>与运算符，两位都为1时，结果为1，否则为0。</p>
<p>2.<code>|</code> 运算符</p>
<p>或运算符，两位都为0时，结果为0，否则为1。</p>
<p>3.<code>^</code> 运算符</p>
<p>异或运算符，两位相同时为1，不同为0。</p>
<span id="more"></span>
<p>4.<code>~</code> 运算符</p>
<p>取反运算符，按位取反。</p>
<p>5.<code>&lt;&lt;</code> 左移运算符</p>
<p>向左移动x位，数值大小变为原来的2x倍</p>
<p>取模，例如int型整数有32位，至多移32位，对于1&lt;&lt;35,1&lt;&lt;3结果是相同的。</p>
<p>6.<code>&gt;&gt;</code> 右移运算符</p>
<p>向右移动x位，数值大小缩小为原来的2x倍，由逻辑右移和算数右移两种，在C++中取决于数据类型</p>
<h3 id="运算定律">运算定律</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>交换律始终成立</p>
</li>
<li class="lvl-2">
<p>结合律只对单一运算成立</p>
</li>
<li class="lvl-2">
<p><code>&amp;</code> <code>|</code>是不可逆运算，造成信息丢失，仅仅构成交换幺半群</p>
</li>
<li class="lvl-2">
<p><code>^</code> 符合结合律，<code>^0不变</code>，也就是说，<code>^</code> 运算在S = {0, 1}下构成一个幺半群，其单位元为0，且任意元素的可逆元素为自身，则构成了一个群，另外，由于位运算交换律始终成立，这个群又是一个阿贝尔群（交换群）。</p>
</li>
<li class="lvl-2">
<p><code>证明如下</code><br>
$<br>
我们说(S, *)是一个幺半群,该二元运算满足结合律，且具有单位元，即<br>
$<br>
$$<br>
(1)\forall x, y, z \in S, x * (y * z) = (x * y) * z<br>
$$<br>
$$<br>
(2)\exists 0 \in S, \forall x \in S, 0 * x = x * 0 = x<br>
$$<br>
$<br>
因为(S, *)是一个幺半群，且S中所有元素可逆，我们说(S, *)是一个群，即<br>
$<br>
$$<br>
\forall x \in G, \exists y \in G, x * y = y * x = 0<br>
$$<br>
$<br>
由于位运算符合交换律，(S, *)又是一个阿贝尔群<br>
$</p>
</li>
<li class="lvl-2">
<p>这个证明可以推广到任意位的二进制数上，单位元仍是0b0,逆元仍是元素本身</p>
</li>
</ul>
<h3 id="常用操作">常用操作</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>&amp;</code> <code>|</code> <code>^</code> 对bit的影响</p>
<ul class="lvl-2">
<li class="lvl-4"><code>&amp;0变0</code></li>
<li class="lvl-4"><code>&amp;1不变</code></li>
<li class="lvl-4"><code>|0不变</code></li>
<li class="lvl-4"><code>|1变1</code></li>
<li class="lvl-4"><code>^0不变</code></li>
<li class="lvl-4"><code>^1位取反</code></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">0</span> -&gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> -&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> | <span class="number">0</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">1</span> | <span class="number">0</span> -&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> | <span class="number">1</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">1</span> | <span class="number">1</span> -&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> ^ <span class="number">0</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">1</span> ^ <span class="number">0</span> -&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> ^ <span class="number">1</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">1</span> ^ <span class="number">1</span> -&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>二进制补码相反数</p>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">negate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (~x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取反再加一</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0x1</span>;  <span class="comment">// x == 1</span></span><br><span class="line"><span class="type">int</span> y = ~x + <span class="number">1</span>;   <span class="comment">// y == 0x1111...1110 + 1 == -1</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>交换两个整数值 / 交换且保证两个数的二进制位模式不变</p>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>判断奇偶</p>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((a &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">//是个偶数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment">//是个奇数</span></span><br></pre></td></tr></table></figure>
<h3 id="奇技淫巧？">奇技淫巧？</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>位运算实现<code>x ? y : z</code></p>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    x = !!x;</span><br><span class="line">    <span class="keyword">return</span> (~x + <span class="number">1</span>) &amp; y | ~(~x + <span class="number">1</span>) &amp; z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Tools</category>
      </categories>
  </entry>
  <entry>
    <title>RISC-V</title>
    <url>/2023/04/16/RISC-V/</url>
    <content><![CDATA[<h3 id="Introduction-13">Introduction</h3>
<p>RISC-V是一种精简指令集架构的汇编语言</p>
<h3 id="Feeling-7">Feeling</h3>
<p>RISC-V的核心说明文档只有一页纸那么大，相比起x86臃肿的指令集架构，RISC-V的简单易学很适合作为汇编语言的入门，近年来指令集架构也有从CISC到RISC转变的倾向，但是大部分的机器仍然在x86下运行，整个世界的结构可以说是以x86为主流的。</p>
<h3 id="Links-13">Links</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/riscvcard_large.pdf">RISC-V Green Card in CS61C</a></p>
</li>
<li class="lvl-2">
<p><a href="https://pdos.csail.mit.edu/6.828/2021/reference.html">详尽文档</a></p>
</li>
</ul>
<h3 id="ISA">ISA</h3>
<p>updating…</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Language</category>
      </categories>
      <tags>
        <tag>RISC-V</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 12: Scheduling 2</title>
    <url>/2023/04/15/6-S081-Lecture-12/</url>
    <content><![CDATA[<h3 id="Reading-4">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">Read remainder of “Scheduling”</a></li>
<li class="lvl-2">read code<br>
<img src="/2023/04/15/6-S081-Lecture-12/read12.png" alt="read"></li>
</ul>
<span id="more"></span>
<h3 id="Sleep-and-Wake-up">Sleep and Wake up</h3>
<p><img src="/2023/04/15/6-S081-Lecture-12/sleep1.png" alt></p>
<h3 id="Deadlock">Deadlock</h3>
<p><img src="/2023/04/15/6-S081-Lecture-12/deadlock.png" alt></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>造成死锁的情况是，p1获取了锁，但是通过swtch切换了进程，另一个进程p2也想要获取锁，但p1并没有释放锁，于是p2进入了循环等待的过程中，而这种情况是无法停止下来的，这样获取锁和解除锁的顺序不同导致的问题就叫做死锁</p>
</li>
</ul>
<h3 id="Coodination">Coodination</h3>
<p><img src="/2023/04/15/6-S081-Lecture-12/coor.png" alt></p>
<h3 id="Lost-Wakeups">Lost Wakeups</h3>
<p><img src="/2023/04/15/6-S081-Lecture-12/lost.png" alt></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 11: Scheduling 1</title>
    <url>/2023/04/15/6-S081-Lecture-11/</url>
    <content><![CDATA[<h3 id="Reading-3">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">Read “Scheduling” through Section 7.4</a></li>
<li class="lvl-2">read code<br>
<img src="/2023/04/15/6-S081-Lecture-11/read11.png" alt="read"></li>
</ul>
<span id="more"></span>
<h3 id="Thread">Thread</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>thread - one serial execution 一个串行执行代码的单元，只占用一个cpu</p>
</li>
<li class="lvl-2">
<p>一个线程区别于其他线程的地方是pc, regs, stack</p>
</li>
<li class="lvl-2">
<p>interleave thread</p>
<ul class="lvl-2">
<li class="lvl-4">multi core</li>
<li class="lvl-4">switch</li>
</ul>
</li>
<li class="lvl-2">
<p>shared memory? -&gt; Locks</p>
<ul class="lvl-2">
<li class="lvl-4">xv6 内核线程共享了内存</li>
<li class="lvl-4">xv6 用户进程不共享内存</li>
<li class="lvl-4">Linux 用户进程共享内存</li>
</ul>
</li>
<li class="lvl-2">
<p>其他的多任务解决方案</p>
<ul class="lvl-2">
<li class="lvl-4">事件驱动编程</li>
<li class="lvl-4">状态机</li>
</ul>
</li>
<li class="lvl-2">
<p>challenge</p>
<ul class="lvl-2">
<li class="lvl-4">switch - interleave 线程调度（scheduling）</li>
<li class="lvl-4">what to save / restore</li>
<li class="lvl-4">compute - bound 运算密集进程不肯让出cpu
<ul class="lvl-4">
<li class="lvl-6">timer interrupts</li>
<li class="lvl-6">kernel handler</li>
<li class="lvl-6">yield - switch</li>
<li class="lvl-6">pre-emptive scheduling 抢占式调度</li>
<li class="lvl-6">voluntary scheduling 自愿调度</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p>线程的state</p>
<ul class="lvl-2">
<li class="lvl-4">running 在运行</li>
<li class="lvl-4">runnable 等待被运行</li>
<li class="lvl-4">sleeping 由于系统调用在等待I/O设备等</li>
</ul>
</li>
</ul>
<h3 id="Context-Switch">Context Switch</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>简化的线程切换过程<br>
<img src="/2023/04/15/6-S081-Lecture-11/simple.png" alt></p>
<ul class="lvl-2">
<li class="lvl-4">其主要的设计在于，当要切换线程时，不在用户层直接切换，而在内核切换</li>
</ul>
</li>
<li class="lvl-2">
<p>完整的线程切换过程<br>
<img src="/2023/04/15/6-S081-Lecture-11/complex.png" alt></p>
<ul class="lvl-2">
<li class="lvl-4">每个用户线程对应一个内核线程</li>
<li class="lvl-4">每个内核线程拥有一个context</li>
<li class="lvl-4">每个cpu核心拥有一个调度器线程和保存在cpu结构体中的调度器context</li>
<li class="lvl-4">用户线程p1由于timer interrupt或是系统调用等待I/O设备，其数据被保存在tf1中进入对应的内核线程k1</li>
<li class="lvl-4">内核线程k1数据被保存在其对应的context并switch到调度器线程s0</li>
<li class="lvl-4">调度器线程数据被保存在调度器context并跳到另一个runnable状态的内核线程k2</li>
<li class="lvl-4">内核线程k2通过其对应的context恢复数据后执行c程序，该程序通过先前已经被保存的tf2恢复用户进程p2的数据，将运行的线程切换到p2</li>
<li class="lvl-4">context switch有不同含义，在本课中特指在内核空间中内核线程与调度器线程之间的切换</li>
</ul>
</li>
<li class="lvl-2">
<p>何为“数据”</p>
<ul class="lvl-2">
<li class="lvl-4">在p1切换到k1的过程中，数据被保存在trapframe中，主要包括pc，32个通用寄存器和一些有关trap机制的寄存器</li>
<li class="lvl-4">在k1切换到s0的过程中，数据被保存在context中，主要包括32个通用寄存器中的callee saved register。不保存pc的原因是在调用切换函数时，pc已经被更改了，没有保存pc的必要</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 8: Q&amp;A labs</title>
    <url>/2023/04/15/6-S081-Lecture-8/</url>
    <content><![CDATA[<h3 id="pagetable-lab">pagetable lab</h3>
<ul class="lvl-0">
<li class="lvl-2">似乎讲解的是2020的lab，与2021的lab不同</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab traps</title>
    <url>/2023/04/13/6-S081-Lab-traps/</url>
    <content><![CDATA[<h3 id="Compulsory-exercises-5">Compulsory exercises</h3>
<h4 id="Preparation-5">Preparation</h4>
<ul class="lvl-0">
<li class="lvl-2">reading<br>
<img src="/2023/04/13/6-S081-Lab-traps/pre.png" alt></li>
<li class="lvl-2">To start the lab, switch to the trap branch</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git checkout traps</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="RISC-V-assembly-easy">RISC-V assembly (easy)</h4>
<ul class="lvl-0">
<li class="lvl-2">Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?
<ul class="lvl-2">
<li class="lvl-4">a0-a1 a2-a7; a2</li>
</ul>
</li>
<li class="lvl-2">Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)
<ul class="lvl-2">
<li class="lvl-4">f in printf 0x34 , g in f 0x14</li>
</ul>
</li>
<li class="lvl-2">At what address is the function printf located?
<ul class="lvl-2">
<li class="lvl-4">0x630</li>
</ul>
</li>
<li class="lvl-2">What value is in the register ra just after the jalr to printf in main?
<ul class="lvl-2">
<li class="lvl-4">0x38</li>
</ul>
</li>
<li class="lvl-2">Run the following code.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>  
<ul class="lvl-0">
<li class="lvl-2">What is the output?
<ul class="lvl-2">
<li class="lvl-4">注意字节序是小端序</li>
<li class="lvl-4">He110 World</li>
</ul>
</li>
<li class="lvl-2">The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?
<ul class="lvl-2">
<li class="lvl-4">i = 0x72646c00 -&gt; “ord\0”</li>
<li class="lvl-4">no</li>
</ul>
</li>
<li class="lvl-2">In the following code, what is going to be printed after ‘y=’? (note: the answer is not a specific value.) Why does this happen?</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d y=%d&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure> 
<ul class="lvl-0">
<li class="lvl-4">x=3 y=寄存器a2的十进制值，因为在printf没有传入第三个参数，a2没有被更新，因此直接把原来a2的值传入</li>
</ul>
<h4 id="Backtrace-moderate">Backtrace (moderate)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>该任务是打印出错堆栈前的所有返回地址ra</p>
</li>
<li class="lvl-2">
<p>Implement a backtrace() function in kernel/printf.c<br>
<img src="/2023/04/13/6-S081-Lab-traps/back.png" alt></p>
</li>
<li class="lvl-2">
<p>添加定义和内联函数(内核中)</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>defs.h //printf.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>            <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>  
<figure class="highlight c"><figcaption><span>riscv.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// store frame pointer</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
<ul class="lvl-0">
<li class="lvl-2">
<p>注意ra在fp-8处，上一个fp在fp-16处</p>
</li>
<li class="lvl-2">
<p>使用riscv中的宏定义PGROUNDDOWN(fp)和PGROUNDUP(fp)确定循环终止条件</p>
</li>
<li class="lvl-2">
<p>实现backtrace()</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>kernel/printf.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">    uint64 fp = r_fp();</span><br><span class="line">    uint64 start = PGROUNDDOWN(fp);</span><br><span class="line">    uint64 end = PGROUNDUP(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= fp &amp;&amp; fp &lt;= end) &#123;</span><br><span class="line">        uint64 ra = *(uint64*)(fp - <span class="number">8</span>);</span><br><span class="line">        fp = *(uint64*)(fp - <span class="number">16</span>);       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, ra);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<ul class="lvl-0">
<li class="lvl-2">
<p>添加至sys_sleep()和panic()</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>sysproc.c</span></figcaption><table><tr><td class="code"><pre><span class="line">backtrace();</span><br></pre></td></tr></table></figure> 
<figure class="highlight c"><figcaption><span>kernel/printf.c panic()</span></figcaption><table><tr><td class="code"><pre><span class="line">backtrace();</span><br></pre></td></tr></table></figure> 
<h4 id="Alarm-hard">Alarm (hard)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>添加系统调用在计时器中断时打印alarm</p>
</li>
<li class="lvl-2">
<p>test0: invoke handler<br>
<img src="/2023/04/13/6-S081-Lab-traps/test0.png" alt></p>
</li>
<li class="lvl-2">
<p>修改proc.h</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>proc.h struct proc</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ticks;</span><br><span class="line">uint64 handler;</span><br><span class="line"><span class="type">int</span> gonetick;</span><br></pre></td></tr></table></figure> 
<ul class="lvl-0">
<li class="lvl-2">
<p>需要完成sigalarm系统调用,并且添加sigreturn系统调用（空）</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>sysproc.c</span></figcaption><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ticks;</span><br><span class="line">    uint64 handler;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    p-&gt;ticks = ticks;</span><br><span class="line">    p-&gt;handler = handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//test0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
<ul class="lvl-0">
<li class="lvl-2">
<p>修改usertrap()</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>trap.c usertrap()</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//test0</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">  p-&gt;gonetick += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;ticks_pass % p-&gt;ticks == <span class="number">0</span>) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;epc = p-&gt;handler;</span><br><span class="line">  &#125;</span><br><span class="line">  yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
<ul class="lvl-0">
<li class="lvl-2">
<p>test1/test2(): resume interrupted code<br>
<img src="/2023/04/13/6-S081-Lab-traps/test12.png" alt></p>
</li>
<li class="lvl-2">
<p>test0尚未完成返回，因此程序在alarm后崩溃，需要补全sigreturn</p>
</li>
<li class="lvl-2">
<p>修改proc.h用于保存alarm时的寄存器信息，inhandler防止函数被多次调用</p>
</li>
<li class="lvl-2">
<p>需要初始化的参数可以通过allocproc()初始化</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>proc.h struct proc >folded</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ticks;</span><br><span class="line">uint64 handler;</span><br><span class="line"><span class="type">int</span> gonetick;</span><br><span class="line"><span class="type">int</span> inhandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line"><span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line"><span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line"><span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line"><span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line"><span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line"><span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line"><span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line"><span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line"><span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line"><span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line"><span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line"><span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line"><span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line"><span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line"><span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line"><span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line"><span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line"><span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line"><span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line"><span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line"><span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line"><span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line"><span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line"><span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line"><span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line"><span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line"><span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line"><span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line"><span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line"><span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line"></span><br><span class="line">uint64 epc;</span><br></pre></td></tr></table></figure> 
<ul class="lvl-0">
<li class="lvl-2">
<p>完成sigreturn系统调用</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>sysproc.c >folded</span></figcaption><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ticks;</span><br><span class="line">    uint64 handler;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    p-&gt;ticks = ticks;</span><br><span class="line">    p-&gt;handler = handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//test12</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;trapframe-&gt;ra = p-&gt;ra;</span><br><span class="line">  p-&gt;trapframe-&gt;sp = p-&gt;sp;</span><br><span class="line">  p-&gt;trapframe-&gt;gp = p-&gt;gp;</span><br><span class="line">  p-&gt;trapframe-&gt;tp = p-&gt;tp;</span><br><span class="line">  p-&gt;trapframe-&gt;t0 = p-&gt;t0;</span><br><span class="line">  p-&gt;trapframe-&gt;t1 = p-&gt;t1;</span><br><span class="line">  p-&gt;trapframe-&gt;t2 = p-&gt;t2;</span><br><span class="line">  p-&gt;trapframe-&gt;s0 = p-&gt;s0;</span><br><span class="line">  p-&gt;trapframe-&gt;s1 = p-&gt;s1;</span><br><span class="line">  p-&gt;trapframe-&gt;a0 = p-&gt;a0;</span><br><span class="line">  p-&gt;trapframe-&gt;a1 = p-&gt;a1;</span><br><span class="line">  p-&gt;trapframe-&gt;a2 = p-&gt;a2;</span><br><span class="line">  p-&gt;trapframe-&gt;a3 = p-&gt;a3;</span><br><span class="line">  p-&gt;trapframe-&gt;a4 = p-&gt;a4;</span><br><span class="line">  p-&gt;trapframe-&gt;a5 = p-&gt;a5;</span><br><span class="line">  p-&gt;trapframe-&gt;a6 = p-&gt;a6;</span><br><span class="line">  p-&gt;trapframe-&gt;a7 = p-&gt;a7;</span><br><span class="line">  p-&gt;trapframe-&gt;s2 = p-&gt;s2;</span><br><span class="line">  p-&gt;trapframe-&gt;s3 = p-&gt;s3;</span><br><span class="line">  p-&gt;trapframe-&gt;s4 = p-&gt;s4;</span><br><span class="line">  p-&gt;trapframe-&gt;s5 = p-&gt;s5;</span><br><span class="line">  p-&gt;trapframe-&gt;s6 = p-&gt;s6;</span><br><span class="line">  p-&gt;trapframe-&gt;s7 = p-&gt;s7;</span><br><span class="line">  p-&gt;trapframe-&gt;s8 = p-&gt;s8;</span><br><span class="line">  p-&gt;trapframe-&gt;s9 = p-&gt;s9;</span><br><span class="line">  p-&gt;trapframe-&gt;s10 = p-&gt;s10;</span><br><span class="line">  p-&gt;trapframe-&gt;s11 = p-&gt;s11;</span><br><span class="line">  p-&gt;trapframe-&gt;t3 = p-&gt;t3;</span><br><span class="line">  p-&gt;trapframe-&gt;t4 = p-&gt;t4;</span><br><span class="line">  p-&gt;trapframe-&gt;t5 = p-&gt;t5;</span><br><span class="line">  p-&gt;trapframe-&gt;t6 = p-&gt;t6;</span><br><span class="line"></span><br><span class="line">  p-&gt;trapframe-&gt;epc = p-&gt;epc;</span><br><span class="line">  p-&gt;inhandler = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
<ul class="lvl-0">
<li class="lvl-2">
<p>修改usertrap()</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>trap.c usertrap() >folded</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//test12</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; p-&gt;inhandler == <span class="number">0</span>) &#123;</span><br><span class="line">  p-&gt;gonetick += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;ticks &amp;&amp; p-&gt;gonetick == p-&gt;ticks) &#123;</span><br><span class="line">    p-&gt;gonetick = <span class="number">0</span>;</span><br><span class="line">    p-&gt;inhandler = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    p-&gt;ra = p-&gt;trapframe-&gt;ra;</span><br><span class="line">    p-&gt;sp = p-&gt;trapframe-&gt;sp;</span><br><span class="line">    p-&gt;gp = p-&gt;trapframe-&gt;gp;</span><br><span class="line">    p-&gt;tp = p-&gt;trapframe-&gt;tp;</span><br><span class="line">    p-&gt;t0 = p-&gt;trapframe-&gt;t0;</span><br><span class="line">    p-&gt;t1 = p-&gt;trapframe-&gt;t1;</span><br><span class="line">    p-&gt;t2 = p-&gt;trapframe-&gt;t2;</span><br><span class="line">    p-&gt;s0 = p-&gt;trapframe-&gt;s0;</span><br><span class="line">    p-&gt;s1 = p-&gt;trapframe-&gt;s1;</span><br><span class="line">    p-&gt;a0 = p-&gt;trapframe-&gt;a0;</span><br><span class="line">    p-&gt;a1 = p-&gt;trapframe-&gt;a1;</span><br><span class="line">    p-&gt;a2 = p-&gt;trapframe-&gt;a2;</span><br><span class="line">    p-&gt;a3 = p-&gt;trapframe-&gt;a3;</span><br><span class="line">    p-&gt;a4 = p-&gt;trapframe-&gt;a4;</span><br><span class="line">    p-&gt;a5 = p-&gt;trapframe-&gt;a5;</span><br><span class="line">    p-&gt;a6 = p-&gt;trapframe-&gt;a6;</span><br><span class="line">    p-&gt;a7 = p-&gt;trapframe-&gt;a7;</span><br><span class="line">    p-&gt;s2 = p-&gt;trapframe-&gt;s2;</span><br><span class="line">    p-&gt;s3 = p-&gt;trapframe-&gt;s3;</span><br><span class="line">    p-&gt;s4 = p-&gt;trapframe-&gt;s4;</span><br><span class="line">    p-&gt;s5 = p-&gt;trapframe-&gt;s5;</span><br><span class="line">    p-&gt;s6 = p-&gt;trapframe-&gt;s6;</span><br><span class="line">    p-&gt;s7 = p-&gt;trapframe-&gt;s7;</span><br><span class="line">    p-&gt;s8 = p-&gt;trapframe-&gt;s8;</span><br><span class="line">    p-&gt;s9 = p-&gt;trapframe-&gt;s9;</span><br><span class="line">    p-&gt;s10 = p-&gt;trapframe-&gt;s10;</span><br><span class="line">    p-&gt;s11 = p-&gt;trapframe-&gt;s11;</span><br><span class="line">    p-&gt;t3 = p-&gt;trapframe-&gt;t3;</span><br><span class="line">    p-&gt;t4 = p-&gt;trapframe-&gt;t4;</span><br><span class="line">    p-&gt;t5 = p-&gt;trapframe-&gt;t5;</span><br><span class="line">    p-&gt;t6 = p-&gt;trapframe-&gt;t6;   </span><br><span class="line"></span><br><span class="line">    p-&gt;epc = p-&gt;trapframe-&gt;epc;     </span><br><span class="line"></span><br><span class="line">    p-&gt;trapframe-&gt;epc = p-&gt;handler;</span><br><span class="line">  &#125;</span><br><span class="line">  yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
<h3 id="Optional-challenge-exercises-5">Optional challenge exercises</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Print the names of the functions and line numbers in backtrace() instead of numerical addresses (hard).</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF</title>
    <url>/2023/04/13/CTF/</url>
    <content><![CDATA[<h3 id="Introduction">Introduction</h3>
<p>CTF（Capture The Flag）夺旗赛，是网络安全爱好者之间的竞技游戏。</p>
<h3 id="Links">Links</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://ctf-wiki.org">CTF wiki</a></li>
<li class="lvl-2"><a href="https://www.ctfhub.com">CTFHub</a></li>
</ul>
<span id="more"></span>
<p>updating…</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell</title>
    <url>/2023/04/10/Shell/</url>
    <content><![CDATA[<h3 id="Introduction-15">Introduction</h3>
<p>Shell通常是运行在操作系统用户层的一个程序，它的表现很像操作系统的外壳(Shell)，它接受键盘输入并执行程序，将结果写入到标准输出流中。shell的种类很多，有bash，zsh，fish等</p>
<span id="more"></span>
<h3 id="Common-Usage-wsl">Common Usage(wsl)</h3>
<h4 id="文件和目录">文件和目录</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>ls</code> 列出当前路径下的文件和目录</p>
<ul class="lvl-2">
<li class="lvl-4"><code>-a</code> 列出包括隐藏文件的文件和目录</li>
<li class="lvl-4"><code>-l</code> 列出详细信息</li>
</ul>
</li>
<li class="lvl-2">
<p><code>pwd</code> 显示当前目录</p>
</li>
<li class="lvl-2">
<p><code>touch &lt;filename&gt;</code> 创建新文件</p>
</li>
<li class="lvl-2">
<p><code>mkdir &lt;dirname</code> 创建新目录</p>
</li>
<li class="lvl-2">
<p><code>rm &lt;filename&gt;</code> 删除文件</p>
<ul class="lvl-2">
<li class="lvl-4"><code>-r</code> 递归删除目录</li>
<li class="lvl-4"><code>-f</code> 强制删除文件</li>
</ul>
</li>
<li class="lvl-2">
<p><code>rmdir &lt;dirname&gt;</code> 删除空目录</p>
<ul class="lvl-2">
<li class="lvl-4"><code>rm -r &lt;dirname&gt;</code> 删除目录下所有内容</li>
</ul>
</li>
<li class="lvl-2">
<p><code>mv src dst</code> 移动文件或目录(重命名)</p>
</li>
<li class="lvl-2">
<p><code>find path -name patten</code> 查找path下文件名匹配pattern的文件</p>
</li>
<li class="lvl-2">
<p><code>cd &lt;path&gt;</code> 转换工作路径</p>
<ul class="lvl-2">
<li class="lvl-4"><code>.</code> 此目录</li>
<li class="lvl-4"><code>..</code> 父目录</li>
<li class="lvl-4"><code>~</code> 根目录</li>
<li class="lvl-4"><code>-</code> 切换前的目录</li>
<li class="lvl-4"><code>/</code> 开头代表绝对路径</li>
<li class="lvl-4">无 <code>/</code> 开头代表相对路径</li>
</ul>
</li>
</ul>
<h4 id="快捷键">快捷键</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>man readline</code> 可以查看 Bash 中的默认快捷键。内容有很多，例如 <code>alt-.</code> 循环地移向前一个参数，而 <code>alt-*</code> 可以展开通配符。</p>
</li>
<li class="lvl-2">
<p><code>ctrl-w</code> 删除你键入的最后一个单词</p>
</li>
<li class="lvl-2">
<p><code>ctrl-u</code> 可以删除行内光标所在位置之前的内容，</p>
</li>
<li class="lvl-2">
<p><code>alt-b</code> 和 <code>alt-f</code> 可以以单词为单位移动光标，</p>
</li>
<li class="lvl-2">
<p><code>ctrl-a</code> 可以将光标移至行首</p>
</li>
<li class="lvl-2">
<p><code>ctrl-e</code> 可以将光标移至行尾</p>
</li>
<li class="lvl-2">
<p><code>ctrl-k</code> 可以删除光标至行尾的所有内容</p>
</li>
<li class="lvl-2">
<p><code>ctrl-l</code> 可以清屏。</p>
</li>
<li class="lvl-2">
<p><code>ctrl-c</code></p>
</li>
<li class="lvl-2">
<p><code>ctrl-z</code></p>
</li>
<li class="lvl-2">
<p><code>ctrl-r</code> 搜索命令行历史记录</p>
</li>
</ul>
<h4 id="文件编辑">文件编辑</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>cat &lt;filename&gt;</code> 输出文件内容</p>
<ul class="lvl-2">
<li class="lvl-4"><code>-n</code> 输出行号</li>
</ul>
</li>
<li class="lvl-2">
<p><code>vim &lt;filename&gt;</code> 用Vim打开或创建一个文件</p>
</li>
<li class="lvl-2">
<p><code>code &lt;path&gt;</code> 用vscode打开目录（需要安装插件？）</p>
</li>
</ul>
<h4 id="包管理器">包管理器</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>apt-get</code></p>
</li>
<li class="lvl-2">
<p><code>yum</code></p>
</li>
<li class="lvl-2">
<p><code>dnf</code></p>
</li>
<li class="lvl-2">
<p><code>pacman</code></p>
</li>
<li class="lvl-2">
<p><code>pip</code></p>
</li>
<li class="lvl-2">
<p><code>npm</code></p>
</li>
</ul>
<h4 id="网络">网络</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>ssh</code></p>
</li>
</ul>
<h4 id="自定义配置">自定义配置</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>vim ~/.bashrc</code></p>
</li>
</ul>
<h3 id="Links-15">Links</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">详细命令</a></p>
</li>
</ul>
<p>updating…</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Tools</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim</title>
    <url>/2023/04/09/Vim/</url>
    <content><![CDATA[<h3 id="Introduction-17">Introduction</h3>
<p>Vim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器</p>
<span id="more"></span>
<h3 id="Usage-3">Usage</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://missing.csail.mit.edu/2020/editors/">参考教程</a></p>
</li>
<li class="lvl-2">
<p>基本键位<br>
<img src="/2023/04/09/Vim/vim.png" alt="vim"></p>
</li>
<li class="lvl-2">
<p>自定义配置 <code>vim .vimrc</code></p>
</li>
<li class="lvl-2">
<p>插件安装</p>
<ul class="lvl-2">
<li class="lvl-4"><a href="https://vimawesome.com/">vimawesome</a></li>
<li class="lvl-4">在<code>.vimrc</code>中</li>
</ul>
</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; Plug</span></span><br><span class="line"><span class="keyword">call</span> plug#begin()</span><br><span class="line">Plug <span class="string">&#x27;scrooloose/nerdtree&#x27;</span></span><br><span class="line"><span class="comment">&quot;Plug &#x27;vim-jp/vim-cpp&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;valloric/youcompleteme&#x27;</span></span><br><span class="line"><span class="comment">&quot; Plug &#x27;wikitopian/hardmode&#x27;  </span></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Tools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 10: Multiprocessors and locking</title>
    <url>/2023/04/08/6-S081-Lecture-10/</url>
    <content><![CDATA[<h3 id="Reading-2">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">Read Locking</a></li>
<li class="lvl-2">read code<br>
<img src="/2023/04/08/6-S081-Lecture-10/read10.png" alt="read"></li>
</ul>
<span id="more"></span>
<h3 id="Locks-introduction">Locks introduction</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>apps wants to multiple cores</p>
</li>
<li class="lvl-2">
<p>kernel must handle parallel sys calls</p>
</li>
<li class="lvl-2">
<p>access shared data structure in parallel</p>
</li>
<li class="lvl-2">
<p>-&gt; locks for correct sharing</p>
</li>
<li class="lvl-2">
<p>locks limit performance</p>
</li>
</ul>
<h3 id="Microprocessor-trend">Microprocessor trend</h3>
<p><img src="/2023/04/08/6-S081-Lecture-10/micro.png" alt="micro"></p>
<h3 id="Lock-abstraction">Lock abstraction</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>struct lock</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acquire(&amp;l)</span><br><span class="line"><span class="comment">// critical section</span></span><br><span class="line"><span class="comment">// your code here</span></span><br><span class="line">release(&amp;l)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>程序有很多把锁，如果只有一把，串行影响性能，为达到某种程度的并行且保证正确性，程序使用多把锁</p>
</li>
</ul>
<h3 id="When-to-lock">When to lock?</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Constructive Rule: two process access a shared data structure + one is writing</p>
</li>
<li class="lvl-2">
<p>too strict: lock free programming</p>
</li>
<li class="lvl-2">
<p>too loose: printf(“xxxx”)</p>
</li>
</ul>
<h3 id="Could-locking-be-automatic">Could locking be automatic?</h3>
<h3 id="Lock-perspective">Lock perspective</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>avoid lost update</p>
</li>
<li class="lvl-2">
<p>make multi-step operation atomatic</p>
</li>
<li class="lvl-2">
<p>help maintain invariant</p>
</li>
</ul>
<h3 id="Dead-lock">Dead lock</h3>
<h3 id="Locks-vs-modual">Locks vs modual</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>lock ordering -&gt; global</p>
</li>
<li class="lvl-2">
<p>锁使模块化变得困难</p>
</li>
</ul>
<h3 id="Locks-vs-performance">Locks vs performance</h3>
<h3 id="Implenment-Lock">Implenment Lock</h3>
<h3 id="memory-ordering">memory ordering</h3>
<p>updating…</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 9: Interrupts</title>
    <url>/2023/04/08/6-S081-Lecture-9/</url>
    <content><![CDATA[<h3 id="Reading-15">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">Read Chapter5</a></li>
<li class="lvl-2">read code<br>
<img src="/2023/04/08/6-S081-Lecture-9/read9.png" alt="read"></li>
</ul>
<span id="more"></span>
<h3 id="Interrupts">Interrupts</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>HW wants attention now, like keyboard and network device</p>
</li>
<li class="lvl-2">
<p>系统调用，traps，interrupts都使用相同的处理模式</p>
<ul class="lvl-2">
<li class="lvl-4">save its work</li>
<li class="lvl-4">process interrupt</li>
<li class="lvl-4">resume its work</li>
</ul>
</li>
<li class="lvl-2">
<p>interrrupts的特殊之处</p>
<ul class="lvl-2">
<li class="lvl-4">asynchronous异步的</li>
<li class="lvl-4">concurrency between cpu and device</li>
<li class="lvl-4">program device</li>
</ul>
</li>
</ul>
<h3 id="Where-interrupts-come-from">Where interrupts come from?</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>主板上的异步接口<br>
<img src="/2023/04/08/6-S081-Lecture-9/board.png" alt></p>
</li>
<li class="lvl-2">
<p>cpu架构<br>
<img src="/2023/04/08/6-S081-Lecture-9/cpu.png" alt></p>
</li>
<li class="lvl-2">
<p>PLIC 平台级中断控制器</p>
</li>
<li class="lvl-2">
<p>UART 通用异步收发器(Universal Asynchronous Receiver/Transmitter)</p>
</li>
</ul>
<h3 id="Driver-manage-device">Driver manage device</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>经典的驱动架构<br>
<img src="/2023/04/08/6-S081-Lecture-9/driver.png" alt="driver"></p>
</li>
</ul>
<h3 id="Programming-Device">Programming Device</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>memory mapped I/O</p>
</li>
<li class="lvl-2">
<p>ld/st read/write control register device</p>
</li>
</ul>
<h3 id="How-does-‘-ls’-work">How does ‘$ ls’ work?</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>device puts ‘$’ into uart</p>
</li>
<li class="lvl-2">
<p>uart generate interrupts when char has been sent</p>
</li>
<li class="lvl-2">
<p>keyboard connect to generate interrupts</p>
</li>
</ul>
<h3 id="RISC-V-support-for-interrupts">RISC-V support for interrupts</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>STE - one bit for E, S, T</p>
</li>
<li class="lvl-2">
<p>SSTATE - bit enable/disable</p>
</li>
<li class="lvl-2">
<p>SIP - interrrupt pending</p>
</li>
<li class="lvl-2">
<p>SCAUSE</p>
</li>
<li class="lvl-2">
<p>STVEC</p>
</li>
</ul>
<h3 id="Interrrupts-and-concurrency">Interrrupts and concurrency</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>device and cpu run in parallel</p>
<ul class="lvl-2">
<li class="lvl-4">producer / consumer parallelism</li>
</ul>
</li>
<li class="lvl-2">
<p>interrupts stops the current program</p>
<ul class="lvl-2">
<li class="lvl-4">user? OK</li>
<li class="lvl-4">kernel? 必要时设置取消interrupts来保证原子性</li>
</ul>
</li>
<li class="lvl-2">
<p>top of device and bottom of device run in parallel</p>
<ul class="lvl-2">
<li class="lvl-4">use locks</li>
</ul>
</li>
</ul>
<h3 id="Interrupts-evolution">Interrupts evolution</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>polling(轮询)</p>
<ul class="lvl-2">
<li class="lvl-4">对于高速设备节省，如高性能网卡</li>
<li class="lvl-4">对于低速设备浪费性能，如键盘</li>
</ul>
</li>
<li class="lvl-2">
<p>interrupts(中断)</p>
</li>
<li class="lvl-2">
<p>动态切换polling和interrupts</p>
</li>
<li class="lvl-2">
<p>Tip: CS61C中关于设备访问的几种方式</p>
<ul class="lvl-2">
<li class="lvl-4">polling相当于到店排队问好了没，好了我拿走</li>
<li class="lvl-4">interrupts相当于准备好了通知你到店自取</li>
<li class="lvl-4">DMA相当于外卖送货上门，你去拿就行了</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>Manim</title>
    <url>/2023/04/06/Manim/</url>
    <content><![CDATA[<h3 id="Introduction-9">Introduction</h3>
<p>Manim是数学视频博主3b1b开发并使用的Python图形引擎，用于制作数学科普视频。<br>
<img src="/2023/04/06/Manim/manim.png" alt="manim"></p>
<h3 id="Usage">Usage</h3>
<h4 id="基本框架">基本框架</h4>
<figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> manimlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SceneName</span>(<span class="title class_ inherited__">Scene</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self</span>):</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Tools</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab pgtbl</title>
    <url>/2023/04/05/6-S081-Lab-pgtbl/</url>
    <content><![CDATA[<h3 id="Compulsory-exercises-3">Compulsory exercises</h3>
<h4 id="Preparation-3">Preparation</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>reading<br>
<img src="/2023/04/05/6-S081-Lab-pgtbl/pre.png" alt="preparation"></p>
</li>
<li class="lvl-2">
<p>To start the lab, switch to the pgtbl branch:</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git checkout pgtbl</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="Speed-up-system-calls-easy">Speed up system calls (easy)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>getpid()作为系统调用，每次调用时需要跳入内核并跳出，为加速pid的获取，ugetpid()函数可以通过分配虚拟地址将pid存入其中，从而实现不跳转不trap获取pid</p>
</li>
<li class="lvl-2">
<p>修改内核函数实现ugetpid()<br>
<img src="/2023/04/05/6-S081-Lab-pgtbl/speed.png" alt="speed"></p>
</li>
<li class="lvl-2">
<p>map one <mark>read-only</mark> page at USYSCALL in proc_pagetable()</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>proc.c proc_pagetable()</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">            (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>allocate and initialize the page in allocproc()</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>proc.c allocproc()</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a usyscall page before creating a new pagetable</span></span><br><span class="line"><span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>free the page in freeproc()</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>proc.c freeproc()</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;usyscall) &#123;</span><br><span class="line">  kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>umap USYSCALL in proc_freepagetable()</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>proc.c proc_freepagetable()</span></figcaption><table><tr><td class="code"><pre><span class="line">uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Print-a-page-table-easy">Print a page table (easy)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>RISC-V架构中的三级页表需要通过递归打印</p>
</li>
<li class="lvl-2">
<p>添加内核函数vmprint()<br>
<img src="/2023/04/05/6-S081-Lab-pgtbl/vmprint.png" alt="vmprint"></p>
</li>
<li class="lvl-2">
<p>prototype for vmprint in defs.h</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>defs.h //vm.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>            <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>put vmprint() in vm.c</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>vm.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// help function</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprinthelp</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *dot;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">2</span>) dot = <span class="string">&quot;..&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">1</span>) dot = <span class="string">&quot;.. ..&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) dot = <span class="string">&quot;.. .. ..&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">        <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">        <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">            uint64 child = PTE2PA(pte);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s%d: pte %p pa %p\n&quot;</span>, dot, i, pte, child);</span><br><span class="line">            <span class="keyword">if</span> (level != <span class="number">0</span>) &#123;</span><br><span class="line">               vmprinthelp((<span class="type">pagetable_t</span>)child, level - <span class="number">1</span>);               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">    vmprinthelp(pagetable, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Detecting-which-pages-have-been-accessed-hard">Detecting which pages have been accessed (hard)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>探测页表中的页是否被访问过</p>
</li>
<li class="lvl-2">
<p>添加pgaccess系统调用<br>
<img src="/2023/04/05/6-S081-Lab-pgtbl/pgaccess.png" alt="pgaccess"></p>
</li>
<li class="lvl-2">
<p>implementing sys_pgaccess() sysproc.c</p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>sysproc.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  uint64 firstpte;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  uint64 buf;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;firstpte) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argint(<span class="number">1</span>, &amp;num) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">2</span>, &amp;buf) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = myproc()-&gt;pagetable;</span><br><span class="line">  pgaccess(pagetable, firstpte, num, buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>define PTE_A, the access bit, in riscv.h 参考下图PTE_A的位置<br>
<img src="/2023/04/05/6-S081-Lab-pgtbl/RISCVPT.png" alt></p>
</li>
</ul>
<figure class="highlight c"><figcaption><span>riscv.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L <span class="string">&lt;&lt; 6) // 1 -&gt;</span> Accessed</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>add pgaccess() in vm.c</p>
<ul class="lvl-2">
<li class="lvl-4">注意第一个page对应mask最低有效位</li>
<li class="lvl-4">注意探测一个带有PTE_A的page过后要消除PTE_A</li>
</ul>
</li>
</ul>
<figure class="highlight c"><figcaption><span>vm.c</span></figcaption><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">pgaccess</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 firstpte, <span class="type">int</span> num, uint64 buf)</span> &#123;</span><br><span class="line">  uint64 mask = <span class="number">0</span>;</span><br><span class="line">  uint64 limit = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (uint64 i = <span class="number">0</span>; i &lt; num &amp;&amp; i &lt; limit; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte_ptr;</span><br><span class="line">    pte_ptr = walk(pagetable, firstpte + i * (uint64)PGSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((pte_ptr != <span class="number">0</span>) &amp;&amp; (*pte_ptr &amp; PTE_A)) &#123;</span><br><span class="line">        mask = mask | (<span class="number">1L</span> &lt;&lt; i);</span><br><span class="line">        *pte_ptr = *pte_ptr &amp; (~PTE_A);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  copyout(pagetable, buf, (<span class="type">char</span> *)&amp;mask, <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Optional-challenge-exercises-3">Optional challenge exercises</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Use super-pages to reduce the number of PTEs in page tables.</p>
</li>
<li class="lvl-2">
<p>Unmap the first page of a user process so that dereferencing a null pointer will result in a fault. You will have to start the user text segment at, for example, 4096, instead of 0.</p>
</li>
<li class="lvl-2">
<p>Add a system call that reports dirty pages (modified pages) using PTE_D.</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 7: Page faults</title>
    <url>/2023/04/04/6-S081-Lecture-7/</url>
    <content><![CDATA[<h3 id="Reading-14">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">Read 4.6</a></li>
</ul>
<span id="more"></span>
<h3 id="Implenment-VM-features-using-page-fault">Implenment VM features using page fault</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>lazy allocation</p>
</li>
<li class="lvl-2">
<p>copy on write fork</p>
</li>
<li class="lvl-2">
<p>demand paging</p>
</li>
<li class="lvl-2">
<p>memory mapped files</p>
</li>
</ul>
<h3 id="Virtual-Memory-benefits">Virtual Memory benefits</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Isolation</p>
</li>
<li class="lvl-2">
<p>level of indirection</p>
<ul class="lvl-2">
<li class="lvl-4">trampline page</li>
<li class="lvl-4">guard page</li>
</ul>
</li>
</ul>
<h3 id="Information-needed">Information needed</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>the faulting VA -&gt; stval register</p>
</li>
<li class="lvl-2">
<p>type pf fault -&gt; scause register</p>
<ul class="lvl-2">
<li class="lvl-4">load</li>
<li class="lvl-4">store</li>
<li class="lvl-4">pc</li>
</ul>
</li>
<li class="lvl-2">
<p>the VA of Instruction that cause fault -&gt; sepc register | trampframe?</p>
</li>
</ul>
<h3 id="lazy-allocation">lazy allocation</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>sbrk()原本应为进程改变堆的大小，分配内存<br>
<img src="/2023/04/04/6-S081-Lecture-7/sbrk.png" alt="sbrk"></p>
</li>
<li class="lvl-2">
<p>sbrk()系统调用基本不做事情，只p-&gt;size + n</p>
</li>
<li class="lvl-2">
<p>当要使用这一部分内存时，触发Page Fault</p>
<ul class="lvl-2">
<li class="lvl-4">allocate 1 page</li>
<li class="lvl-4">zero page</li>
<li class="lvl-4">map the page</li>
<li class="lvl-4">restart instruction</li>
</ul>
</li>
</ul>
<h3 id="zero-fill-on-demand">zero fill on demand</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>初始化的page VA共用一个PA，即映射到同一个物理地址上(Read Only)<br>
<img src="/2023/04/04/6-S081-Lecture-7/zero.png" alt="zero"></p>
</li>
<li class="lvl-2">
<p>当要写这些page时，触发Page Fault</p>
<ul class="lvl-2">
<li class="lvl-4">copy</li>
<li class="lvl-4">upgrade</li>
<li class="lvl-4">restart instruction</li>
</ul>
</li>
</ul>
<h3 id="copy-on-write-fork">copy on write fork</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>fork()时child使用parent的内存空间，即子进程映射到父进程的物理空间上(Read Only)<br>
<img src="/2023/04/04/6-S081-Lecture-7/cow.png" alt="cow"></p>
</li>
<li class="lvl-2">
<p>当要写子进程，触发Page Fault</p>
<ul class="lvl-2">
<li class="lvl-4">copy page</li>
<li class="lvl-4">map</li>
<li class="lvl-4">restart instruction</li>
<li class="lvl-4">usrret</li>
</ul>
</li>
</ul>
<h3 id="demand-page">demand page</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>当执行exec()系统调用时，load text data segment，eagarly pagetable，但是只在VA中分配，PTE不分配<br>
<img src="/2023/04/04/6-S081-Lecture-7/demand1.png" alt="demand1"></p>
</li>
<li class="lvl-2">
<p>当要执行程序时，触发Page Fault</p>
<ul class="lvl-2">
<li class="lvl-4">read block/page from file into memory</li>
<li class="lvl-4">map men into pgtbl</li>
<li class="lvl-4">restart instruction</li>
</ul>
</li>
<li class="lvl-2">
<p>当内存耗尽时<br>
<img src="/2023/04/04/6-S081-Lecture-7/demand2.png" alt="demand2"></p>
<ul class="lvl-2">
<li class="lvl-4">evict a page -&gt; file</li>
<li class="lvl-4">use the just free page</li>
<li class="lvl-4">restart intruction</li>
</ul>
</li>
<li class="lvl-2">
<p>驱逐什么page? LRU and non-dirty</p>
</li>
<li class="lvl-2">
<p>使用PTE中自定义的RW位实现LRU和dirty<br>
<img src="/2023/04/04/6-S081-Lecture-7/PTE.png" alt="PTE"></p>
</li>
</ul>
<h3 id="memory-mapped-files">memory mapped files</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>当执行ld，sd指令时<br>
<img src="/2023/04/04/6-S081-Lecture-7/mmap.png" alt="mmap"></p>
</li>
<li class="lvl-2">
<p>mmap(VA, len, protection, flags, fd, offset)映射PA到VA</p>
</li>
<li class="lvl-2">
<p>unmap(VA, len) write back dirty block</p>
</li>
</ul>
<h3 id="Summary-for-Page-Table">Summary for Page Table</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>page tables + traps/page fault -&gt; powerful elegent VM features</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 6: Isolation &amp; system call entry/exit</title>
    <url>/2023/04/01/6-S081-Lecture-6/</url>
    <content><![CDATA[<h3 id="Reading-13">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">Read Chapter4</a><br>
<img src="/2023/04/01/6-S081-Lecture-6/Chapter4.png" alt="Chapter4"></li>
<li class="lvl-2">read code<br>
<img src="/2023/04/01/6-S081-Lecture-6/read6.png" alt="read"></li>
</ul>
<span id="more"></span>
<h3 id="Traps">Traps</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>实现用户层和内核层切换的机制</p>
</li>
<li class="lvl-2">
<p>发生在如系统调用、Page Fault、/0的过程中</p>
</li>
<li class="lvl-2">
<p>Traps register<br>
<img src="/2023/04/01/6-S081-Lecture-6/Trapsreg.png" alt="Trapsregister"></p>
<ul class="lvl-2">
<li class="lvl-4">32个通用register 包括sp栈指针</li>
<li class="lvl-4">PC 程序计数器</li>
<li class="lvl-4">MODE 代表当前在用户模式还是内核模式</li>
<li class="lvl-4">SATP 指向pagetable的物理地址</li>
<li class="lvl-4">STVEC 指向trap指令的起始地址 trapoline page</li>
<li class="lvl-4">SEPC 在trap时保存PC</li>
<li class="lvl-4">SSRACTCH 指向trapframe page</li>
</ul>
</li>
<li class="lvl-2">
<p>supervisor mode<br>
<img src="/2023/04/01/6-S081-Lecture-6/supervisor.png" alt="supervisor"></p>
<ul class="lvl-2">
<li class="lvl-4">supervisor mode可以读写上述控制寄存器，并且可以读写PTE_U = 0的page</li>
</ul>
</li>
<li class="lvl-2">
<p>Traps process(shell write as example)<br>
<img src="/2023/04/01/6-S081-Lecture-6/Traps.png" alt="Traps"></p>
<ul class="lvl-2">
<li class="lvl-4">uservec和userret是trampoline.S中的函数</li>
<li class="lvl-4">usertrap()和usertrapret()是trap.c中的函数</li>
<li class="lvl-4">syscall()是syscall.c中的函数，它根据寄存器传入的参数调用不同的系统调用，如sys_write()</li>
<li class="lvl-4">上述文件均在kernel文件夹中</li>
</ul>
</li>
<li class="lvl-2">
<p>内存映射文件(Memory-mapped file access)机制，将用户空间的虚拟地址空间直接映射到文件内容，可以通过内存地址直接读写文件，这比read write系统调用快上许多，这一功能将在Lab mmap中实现</p>
</li>
</ul>
<h3 id="gdb调试traps">gdb调试traps</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>.asm</code>是带有指令地址的汇编代码 <code>.S</code>则没有指令地址</p>
</li>
<li class="lvl-2">
<p><code>ctrl-a c</code> 进入qemu的consolcc</p>
<ul class="lvl-2">
<li class="lvl-4"><code>info mem</code>打印pagetable</li>
</ul>
</li>
<li class="lvl-2">
<p><code>csrrw a0, sscratch, a0</code> 交换了a0和sscratch的内容</p>
</li>
<li class="lvl-2">
<p>在trampoline page中执行traps，trampoline page包含了内核的trap处理代码，这个操作由内核通过stvec小心地映射到用户pagetable，但是由于PTE_U设置为0，所以不受用户影响</p>
</li>
<li class="lvl-2">
<p>在RISC-V中，ecall尽量简单，由软件也即OS实现了traps机制，目的是实现软件的灵活性，ecall只干三件事</p>
<ul class="lvl-2">
<li class="lvl-4">ecall从user mode切换到supervisor mode</li>
<li class="lvl-4">ecall将pc的值保存在sepc</li>
<li class="lvl-4">ecall跳转到stvec指向的指令</li>
</ul>
</li>
<li class="lvl-2">
<p>RISC-V在每个用户进程的pagetable中映射了trapframe page，其中最重要的是保存了32个用户通用寄存器，在进入traps之前，这个地址会保存在sscratch中</p>
</li>
<li class="lvl-2">
<p>trapframe结构定义在proc.h中</p>
</li>
<li class="lvl-2">
<p>之后从user pagetable切换到kernel pagetable，程序之所以没有崩溃的原因是trampoline page在U/K中映射相同</p>
</li>
<li class="lvl-2">
<p>OS总是从Kernel启动，设置好一切与Traps有关的register后转移到User</p>
</li>
<li class="lvl-2">
<p>sret是从supervisor mode切换到user mode的RISCV-V指令</p>
</li>
<li class="lvl-2">
<p>切换kernel pagetable后，我们只是换了个地方执行c程序</p>
</li>
<li class="lvl-2">
<p>在usertrap()中scause = 8，代表我们是因为系统调用来到这里</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab syscall</title>
    <url>/2023/03/31/6-S081-Lab-syscall/</url>
    <content><![CDATA[<h3 id="Compulsory-exercises-2">Compulsory exercises</h3>
<h4 id="Preparation-2">Preparation</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>reading<br>
<img src="/2023/03/31/6-S081-Lab-syscall/pre.png" alt="pre"></p>
</li>
<li class="lvl-2">
<p>To start the lab, switch to the syscall branch:</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout syscall</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="System-call-tracing-moderate">System call tracing (moderate)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>了解trace的过程</p>
<ul class="lvl-2">
<li class="lvl-4">trace.c调用系统调用trace()</li>
<li class="lvl-4">系统调用trace()调用sys_trace()设置进程的mask</li>
</ul>
</li>
<li class="lvl-2">
<p>理解mask的含义</p>
<ul class="lvl-2">
<li class="lvl-4">mask作为作为系统调用序号的掩码，如mask = (1 &lt;&lt; SYS_read) | (1 &lt;&lt; SYS_fork)代表同时trace read 和 fork系统调用</li>
<li class="lvl-4">当mask = 2147483647时代表trace序号1 - 31的系统调用</li>
<li class="lvl-4">question: mask的类型? uint64 or uint32? 理论上都是可行的</li>
</ul>
</li>
<li class="lvl-2">
<p>添加编译依赖<br>
<img src="/2023/03/31/6-S081-Lab-syscall/make.png" alt="make"></p>
</li>
<li class="lvl-2">
<p>添加trace系统调用<br>
<img src="/2023/03/31/6-S081-Lab-syscall/trace.png" alt="trace"></p>
</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <ul class="lvl-0">
<li class="lvl-4">
<p>add sys_trace()</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add in sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint64 m;</span><br><span class="line">    <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;m) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    myproc()-&gt;mask = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add in proc.h struct proc</span></span><br><span class="line">  uint64 mask;                 <span class="comment">// 64bit Mask for syscall trace</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p>Modify fork()</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add in proc.c</span></span><br><span class="line">  <span class="comment">// copy the trace mask from the parent to the child process</span></span><br><span class="line">  np-&gt;mask = p-&gt;mask;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p>Modify the syscall()</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add and modify in syscall.c</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> *syscallNames[] = &#123;</span><br><span class="line">  <span class="string">&quot;&quot;</span>, <span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>,</span><br><span class="line">  <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;fstat&quot;</span>, <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, </span><br><span class="line">  <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>,<span class="string">&quot;uptime&quot;</span>, <span class="string">&quot;open&quot;</span>, </span><br><span class="line">  <span class="string">&quot;write&quot;</span>, <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">  <span class="string">&quot;close&quot;</span>,<span class="string">&quot;trace&quot;</span>,<span class="string">&quot;sysinfo&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// added in lab syscall</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; num) &amp; p-&gt;mask) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscallNames[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h4 id="Sysinfo-moderate">Sysinfo (moderate)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>了解sysinfo的过程</p>
<ul class="lvl-2">
<li class="lvl-4">sysinfotest调用sysinfo()</li>
<li class="lvl-4">系统调用sysinfo()调用sys_sysinfo获取struct sysinfo</li>
</ul>
</li>
<li class="lvl-2">
<p>添加编译依赖<br>
<img src="/2023/03/31/6-S081-Lab-syscall/make2.png" alt="make2"></p>
</li>
<li class="lvl-2">
<p>添加sysinfo系统调用<br>
<img src="/2023/03/31/6-S081-Lab-syscall/sysinfo.png" alt="sysinfo"></p>
</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <ul class="lvl-0">
<li class="lvl-4">
<p>add sysinfo()</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add in sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint64 addr;</span><br><span class="line">    <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">    info.freemem = freemem();</span><br><span class="line">    info.nproc = procnumber();</span><br><span class="line">    <span class="keyword">if</span>(copyout(myproc()-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">add freemem()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add in kalloc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">freemem</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    r = kmem.freelist;</span><br><span class="line">    uint64 count_mem = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r) &#123;</span><br><span class="line">        count_mem += <span class="number">4096</span>;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count_mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">add procnumber()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add in proc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">procnumber</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint64 count = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state != UNUSED) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    </div>
</div>
<h3 id="Optional-challenge-exercises-2">Optional challenge exercises</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Print the system call arguments for traced system calls (easy).</p>
</li>
<li class="lvl-2">
<p>Compute the load average and export it through sysinfo(moderate).</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT</title>
    <url>/2023/03/30/ChatGPT/</url>
    <content><![CDATA[<h3 id="Self-Introduction">Self Introduction</h3>
<p>GPT-4 is OpenAI’s most advanced system, producing safer and more useful responses.<br>
GPT4: I am a language model that is based on a neural network architecture known as GPT (Generative Pre-trained Transformer). This architecture is used in deep learning to generate natural language text by predicting the next word or sequence of words based on the input text. I was pre-trained on a large corpus of text and can generate human-like responses to a wide range of questions and prompts.</p>
<h3 id="Feeling-3">Feeling</h3>
<p>用了一下ChatGPT，非常不错，确实感觉的到我在和一个知识储备很深并且十分耐心的人谈话，希望它能帮助我在后面的学习和生活过程中解答一些疑惑。此外，gpt有提问限制，我也需要精确我的表达来获取我想要的信息。</p>
<h3 id="Links-5">Links</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://chat.openai.com/chat/">与GPT4对话</a></p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>ChatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb</title>
    <url>/2023/03/29/gdb/</url>
    <content><![CDATA[<h2 id="Introduction-18">Introduction</h2>
<p>gdb(GNU Debugger)是GNU项目中调试工具。</p>
<span id="more"></span>
<h2 id="Usage-4">Usage</h2>
<h3 id="Common">Common</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>帮助<br>
<code>help &lt;command-name&gt;</code></p>
</li>
<li class="lvl-2">
<p>运行<br>
<code>run</code> = <code>r</code> 运行到断点<br>
<code>c</code> = <code>continue</code> 继续到断点</p>
</li>
<li class="lvl-2">
<p>断点<br>
<code>b &lt;breakpoint-name&gt;</code> 函数名处打断点<br>
<code>b &lt;location&gt;</code> 在地址处打断点</p>
</li>
<li class="lvl-2">
<p>步进<br>
<code>s</code> C语言步进 进入函数<br>
<code>si</code> 汇编语言步进 进入函数<br>
<code>n</code> C语言步进 不进入函数<br>
<code>ni</code> 汇编语言步进 不进入函数</p>
</li>
<li class="lvl-2">
<p>观察点</p>
</li>
<li class="lvl-2">
<p>打印内存: 使用x命令来打印内存的值，格式为x/nfu addr，以f格式打印从addr开始的n个长度单元为u的内存值。<br>
<code>x/nfu &lt;address&gt;</code></p>
<ul class="lvl-2">
<li class="lvl-4">n：输出单元的个数</li>
<li class="lvl-4">f : 输出格式，如x表示以16进制输出，o表示以8进制数处，默认x，如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i。</li>
<li class="lvl-4">u：一个单元的长度，b表示1byte，h表示2byte（half word），w表示4byte，g表示8byte（giant word）</li>
</ul>
</li>
<li class="lvl-2">
<p>打印变量<br>
<code>print/x &lt;variable&gt;</code></p>
<ul class="lvl-2">
<li class="lvl-4">d 按十进制格式显示变量<br>
x 按十六进制格式显示变量<br>
a 按十六进制格式显示变量<br>
u 按十六进制格式显示无符号整型<br>
o 按八进制格式显示变量<br>
t 按二进制格式显示变量<br>
c 按字符格式显示变量<br>
f 按浮点数格式显示变量</li>
</ul>
</li>
<li class="lvl-2">
<p>打印信息<br>
<code>info registers</code> prints the value of every register.<br>
<code>info frame</code> prints the current stack frame.<br>
<code>list &lt;location&gt;</code> prints the source code of the function<br>
at the specified location.<br>
<code>backtrace</code> might be useful as you work on lab 1</p>
</li>
<li class="lvl-2">
<p>tui<br>
<code>tui enable</code><br>
<code>layout &lt;name&gt;</code> switches to the given layout.</p>
</li>
</ul>
<h3 id="gdbinit">.gdbinit</h3>
<h2 id="Links-18">Links</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="http://www.unknownroad.com/rtfm/gdbtut/gdbtoc.html">不错的教程</a></p>
</li>
</ul>
<p>Updating…</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Tools</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux</title>
    <url>/2023/03/29/tmux/</url>
    <content><![CDATA[<h3 id="Usage">Usage</h3>
<ul class="lvl-0">
<li class="lvl-2">在shell中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux</span></span><br></pre></td></tr></table></figure>
<p><code>ctrl-b c</code> 新建窗口<br>
<code>ctrl-b p</code> 前一个窗口<br>
<code>ctrl-b n</code> 下一个窗口<br>
<code>ctrl-b %</code> 垂直拆分窗口<br>
<code>ctrl-b &quot;</code> 水平拆分窗口<br>
<code>ctrl-b o</code> 在窗口间切换<br>
<code>exit</code> 退出tmux</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Tools</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 5: GDB, calling conventions and stack frames RISC-V</title>
    <url>/2023/03/29/6-S081-Lecture-5/</url>
    <content><![CDATA[<h3 id="Reading-12">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">Read Calling Convention</a></li>
</ul>
<span id="more"></span>
<h3 id="C-RISC-V-Asm">C -&gt; RISC-V Asm</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>C -&gt; Asm -&gt; Binary</p>
</li>
<li class="lvl-2">
<p>(.c) -&gt; (.s) -&gt; (object / .o)</p>
</li>
</ul>
<h3 id="RISC-V-vs-x86-64">RISC-V vs x86-64</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>x86-64</p>
<ul class="lvl-2">
<li class="lvl-4">3本书</li>
<li class="lvl-4">+3inst / month</li>
<li class="lvl-4">CISC</li>
</ul>
</li>
<li class="lvl-2">
<p>RISC-V</p>
<ul class="lvl-2">
<li class="lvl-4">2本书</li>
<li class="lvl-4">更少更简单的指令</li>
<li class="lvl-4">开源</li>
<li class="lvl-4">RISC</li>
</ul>
</li>
<li class="lvl-2">
<p>ARM</p>
<ul class="lvl-2">
<li class="lvl-4">Android</li>
<li class="lvl-4">ios</li>
<li class="lvl-4">RISC</li>
</ul>
</li>
</ul>
<h3 id="gdb-2">gdb</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>见gdb一文</p>
</li>
</ul>
<h3 id="Register">Register</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>寄存器列表<br>
<img src="/2023/03/29/6-S081-Lecture-5/RISCVreg.png" alt="register"></p>
</li>
<li class="lvl-2">
<p>经典的RISC-V函数</p>
<ul class="lvl-2">
<li class="lvl-4">prologue保存callee saved register</li>
<li class="lvl-4">body函数体</li>
<li class="lvl-4">epilogue还原callee saved register</li>
</ul>
</li>
</ul>
<h3 id="Stack-Frame">Stack Frame</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>栈帧<br>
<img src="/2023/03/29/6-S081-Lecture-5/stackFrame.png" alt="stackFrame"></p>
</li>
<li class="lvl-2">
<p>重要的两个register</p>
<ul class="lvl-2">
<li class="lvl-4">sp -&gt; bottem of stack</li>
<li class="lvl-4">fp -&gt; top of current frame</li>
</ul>
</li>
</ul>
<h3 id="struct">struct</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>连续的内存结构，看成可变数据类型的数组</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 4: Page tables</title>
    <url>/2023/03/29/6-S081-Lecture-4/</url>
    <content><![CDATA[<h3 id="Reading-11">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">Read Chapter3</a><br>
<img src="/2023/03/29/6-S081-Lecture-4/Chapter3.png" alt="Chapter3"></li>
<li class="lvl-2">read code<br>
<img src="/2023/03/29/6-S081-Lecture-4/read4.png" alt="read"></li>
</ul>
<span id="more"></span>
<h3 id="Address-Spaces">Address Spaces</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个进程拥有专属的地址空间</p>
</li>
<li class="lvl-2">
<p>Page table实现了同一个物理内存，不同的地址空间</p>
</li>
<li class="lvl-2">
<p>读写satp寄存器是特殊权限指令</p>
</li>
<li class="lvl-2">
<p>PT H/W<br>
<img src="/2023/03/29/6-S081-Lecture-4/pageHW.png" alt="pageHW"></p>
</li>
<li class="lvl-2">
<p>不为每个地址(1Byte)创建表单条目,而为每个Page(通常4KB，Offset12位)创建一个表单条目</p>
</li>
<li class="lvl-2">
<p>VA -&gt; PA<br>
<img src="/2023/03/29/6-S081-Lecture-4/VAtoPA.png" alt="VA -&gt; PA"></p>
</li>
</ul>
<h3 id="Real-paging-H-W-RISC-V">Real paging H/W (RISC-V)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>三级缓存的RISC-V Page<br>
<img src="/2023/03/29/6-S081-Lecture-4/RISCVPT.png" alt="RISCVPT"></p>
</li>
</ul>
<h3 id="TLB-Translation-Lookaside-Buffer">TLB: Translation Lookaside Buffer</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>cache of PTE(page table entry)</p>
</li>
<li class="lvl-2">
<p>When switch PT, clear TLB</p>
</li>
</ul>
<h3 id="OS-and-PTE">OS and PTE</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>OS可以操纵PTE</p>
</li>
<li class="lvl-2">
<p>Page Fault很有用</p>
</li>
<li class="lvl-2">
<p>虚拟地址映射到内存和I/O设备</p>
<ul class="lvl-2">
<li class="lvl-4">高于0x80000000 -&gt; DRAM</li>
<li class="lvl-4">低于0x80000000 -&gt; I/O</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 3: OS organization and system calls</title>
    <url>/2023/03/28/6-S081-Lecture-3/</url>
    <content><![CDATA[<h3 id="Reading-10">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">Read Chapter2</a><br>
<img src="/2023/03/28/6-S081-Lecture-3/Chapter2.png" alt="Chapter2"></li>
<li class="lvl-2">read code<br>
<img src="/2023/03/28/6-S081-Lecture-3/read.png" alt="read"></li>
</ul>
<span id="more"></span>
<h3 id="Isolation">Isolation</h3>
<p>如果没有OS隔离，用户应用直接与硬件交互，难以实现Multiplexing</p>
<h3 id="Unix-Interface">Unix Interface</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>抽象关系</p>
<ul class="lvl-2">
<li class="lvl-4">OS -&gt; H/W</li>
<li class="lvl-4">process -&gt; CPU</li>
<li class="lvl-4">exec -&gt; Memory</li>
<li class="lvl-4">files -&gt; disk block</li>
</ul>
</li>
</ul>
<h3 id="Defensive">Defensive</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Isolation between apps and OS</p>
</li>
<li class="lvl-2">
<p>HW support</p>
<ul class="lvl-2">
<li class="lvl-4">user / kernel mode<br>
user mode被允许执行add sub等指令，而kernel mode被允许执行受限指令</li>
<li class="lvl-4">virtual memory</li>
</ul>
</li>
</ul>
<h3 id="Virtual-Memory">Virtual Memory</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Page table将虚拟地址映射到物理地址</p>
</li>
<li class="lvl-2">
<p>每个独立的进程有独立的page table，因此实现了不同进程间的内存隔离</p>
</li>
</ul>
<h3 id="Kernel">Kernel</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Kernel -&gt; TCB(可信任的计算空间)</p>
<ul class="lvl-2">
<li class="lvl-4">无bug</li>
<li class="lvl-4">把apps当作恶意的</li>
</ul>
</li>
<li class="lvl-2">
<p>内核架构</p>
<ul class="lvl-2">
<li class="lvl-4">宏内核(Linux)</li>
<li class="lvl-4">微内核(两倍跳转，低performance)</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 2: C and gdb</title>
    <url>/2023/03/28/6-S081-Lecture-2/</url>
    <content><![CDATA[<h3 id="Reading-9">Reading</h3>
<h4 id="C">C</h4>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/lec/6S081-Intro-to-C-Fa21.pdf">Intro to C</a></li>
</ul>
<h4 id="gdb">gdb</h4>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/lec/gdb_slides.pdf">Using the GNU Debugger</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lecture 1: Introduction and examples</title>
    <url>/2023/03/28/6-S081-Lecture-1/</url>
    <content><![CDATA[<h3 id="Reading">Reading</h3>
<ul class="lvl-0">
<li class="lvl-2"><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">Read Chapter1</a><br>
<img src="/2023/03/28/6-S081-Lecture-1/Chapter1.png" alt="Chapter1"></li>
</ul>
<span id="more"></span>
<h3 id="OS-purpose">OS purpose</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Abstract H/W</p>
</li>
<li class="lvl-2">
<p>Multiplex</p>
</li>
<li class="lvl-2">
<p>Isolation</p>
</li>
<li class="lvl-2">
<p>Sharing</p>
</li>
<li class="lvl-2">
<p>Security</p>
</li>
<li class="lvl-2">
<p>Performance</p>
</li>
<li class="lvl-2">
<p>Range of uses</p>
</li>
</ul>
<h3 id="Classic-design">Classic design</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>内核 用户层隔离的设计<br>
<img src="/2023/03/28/6-S081-Lecture-1/Classicdesign.png" alt="Classicdesign"></p>
</li>
</ul>
<h3 id="Why-OS-hard-and-interesting">Why OS hard and interesting?</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>unforgiving</p>
</li>
<li class="lvl-2">
<p>tension</p>
<ul class="lvl-2">
<li class="lvl-4">efficient - abstract</li>
<li class="lvl-4">powerfull - simple</li>
<li class="lvl-4">flexible - secure</li>
</ul>
</li>
<li class="lvl-2">
<p>文件交互和进程交互</p>
</li>
</ul>
<h3 id="program-example-using-Sys-Call">program example using Sys Call</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://pdos.csail.mit.edu/6.828/2021/lec/l-overview/">example</a></p>
</li>
<li class="lvl-2">
<p>copy.c</p>
<ul class="lvl-2">
<li class="lvl-4">使用read write exit系统调用</li>
<li class="lvl-4">fd文件描述符(标准输入输出也只是文件而已)
<ul class="lvl-4">
<li class="lvl-6">0 stdin</li>
<li class="lvl-6">1 stdout</li>
<li class="lvl-6">2 stderr</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p>open.c</p>
<ul class="lvl-2">
<li class="lvl-4">使用open write exit系统调用</li>
</ul>
</li>
<li class="lvl-2">
<p>sh.c</p>
<ul class="lvl-2">
<li class="lvl-4">shell可以被认为仅仅是执行标准输入的命令并打印到标准输出的用户程序</li>
</ul>
</li>
<li class="lvl-2">
<p>fork.c</p>
<ul class="lvl-2">
<li class="lvl-4">使用fork系统调用</li>
</ul>
</li>
<li class="lvl-2">
<p>exec.c</p>
<ul class="lvl-2">
<li class="lvl-4">使用exec系统调用</li>
</ul>
</li>
<li class="lvl-2">
<p>forkexec.c</p>
<ul class="lvl-2">
<li class="lvl-4">使用fork exec wait系统调用</li>
</ul>
</li>
<li class="lvl-2">
<p>redirect.c</p>
<ul class="lvl-2">
<li class="lvl-4">使用fork open exec wait系统调用</li>
<li class="lvl-4">实现了I/O重定向 new.txt -&gt; 1</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab util</title>
    <url>/2023/03/28/6-S081-Lab-util/</url>
    <content><![CDATA[<h3 id="Compulsory-exercises-6">Compulsory exercises</h3>
<h4 id="Lab-guidance">Lab guidance</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">About easy / moderate / hard</a></p>
</li>
</ul>
<span id="more"></span>
<h4 id="Boot-xv6-easy">Boot xv6 (easy)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>启动xv6</p>
</li>
</ul>
<p>在shell中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> xv6-labs-2021</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br></pre></td></tr></table></figure>
<p>在xv6 shell中列出文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>
<p>在xv6中<br>
<code>Ctrl-p</code> 打印进程信息<br>
<code>Ctrl-a x</code> 退出qemu</p>
<h4 id="sleep-easy">sleep (easy)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>了解系统调用</p>
<ul class="lvl-2">
<li class="lvl-4"><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6文档p11</a><br>
<img src="/2023/03/28/6-S081-Lab-util/SysCall.png" alt="Sys Call"></li>
</ul>
</li>
<li class="lvl-2">
<p>代码实现</p>
</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sleep.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//error</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Error arg number!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> time = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">        sleep(time);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<ul class="lvl-0">
<li class="lvl-2">
<p>补全Makefile</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$U/_sleep\</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>测试</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> xv6-labs-2021</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./grade-lab-util <span class="built_in">sleep</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Or <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make GRADEFLAGS=<span class="built_in">sleep</span> grade</span></span><br></pre></td></tr></table></figure>
<h4 id="pingpong-easy">pingpong (easy)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>图解<br>
<img src="/2023/03/28/6-S081-Lab-util/pipe.jpg" alt="pipe"><br>
<img src="/2023/03/28/6-S081-Lab-util/pipe2.jpg" alt="pipe2"></p>
</li>
<li class="lvl-2">
<p>代码实现</p>
</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pingpong.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pipe(p);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        pid = getpid();</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">        read(p[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, pid);</span><br><span class="line">        write(p[<span class="number">1</span>], buf, <span class="number">1</span>);</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        pid = getpid();</span><br><span class="line">        <span class="type">char</span> ball[<span class="number">2</span>] = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">        write(p[<span class="number">1</span>], ball, <span class="number">1</span>);</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        read(p[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, pid);</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h4 id="primes-moderate-hard">primes (moderate)/(hard)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>图解<br>
<img src="/2023/03/28/6-S081-Lab-util/primes.png" alt="primes"></p>
</li>
<li class="lvl-2">
<p>根据分析需要使用两个管道分别用于左邻居和右邻居</p>
</li>
<li class="lvl-2">
<p>代码实现</p>
</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// primes.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">childPrime</span><span class="params">(<span class="type">int</span> p[<span class="number">2</span>])</span> &#123;</span><br><span class="line">    <span class="comment">// p -&gt; left, pr -&gt; right</span></span><br><span class="line">    <span class="comment">// [0] -&gt; read, [1] -&gt; write</span></span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// get first prime</span></span><br><span class="line">    <span class="type">int</span> prime;</span><br><span class="line">    <span class="keyword">if</span> (read(p[<span class="number">0</span>], &amp;prime, <span class="number">4</span>) != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pr[<span class="number">2</span>];</span><br><span class="line">    pipe(pr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        childPrime(pr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">        close(pr[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// drop multiple of prime</span></span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> (read(p[<span class="number">0</span>], &amp;n, <span class="number">4</span>) == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % prime != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (write(pr[<span class="number">1</span>], &amp;n, <span class="number">4</span>) != <span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error&quot;</span>);</span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// close read left</span></span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// close write right</span></span><br><span class="line">        close(pr[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        wait(<span class="number">0</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    pipe(p);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        childPrime(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        <span class="comment">// close read</span></span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(p[<span class="number">1</span>], &amp;i, <span class="number">4</span>) != <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// close write</span></span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h4 id="find-moderate">find (moderate)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>阅读ls.c了解文件系统</p>
</li>
<li class="lvl-2">
<p>代码实现</p>
</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27; &#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *pwd, <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(pwd, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot open %s\n&quot;</span>, pwd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot stat %s\n&quot;</span>, pwd);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> T_FILE:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, filename) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s/%s\n&quot;</span>, pwd, filename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> T_DIR:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(pwd) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;path too long\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, pwd);</span><br><span class="line">        p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">        *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) ==<span class="number">0</span> || \</span><br><span class="line">                <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            memmove(p, de.name, DIRSIZ);</span><br><span class="line">            p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;cannot stat %\n&quot;</span>, buf);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (st.type == T_FILE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, filename) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (st.type == T_DIR) &#123;</span><br><span class="line">                find(buf, filename);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error number!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span>* pwd = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="type">char</span>* filename = argv[<span class="number">2</span>];</span><br><span class="line">        find(pwd, filename);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h4 id="xargs-moderate">xargs (moderate)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>了解xargs</p>
<ul class="lvl-2">
<li class="lvl-4"><a href="https://www.runoob.com/linux/linux-comm-xargs.html">教程</a></li>
<li class="lvl-4">要求实现简易的xarg，即实现下列命令行调用</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . b | xargs grep hello</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello too | xargs <span class="built_in">echo</span> <span class="built_in">bye</span></span></span><br><span class="line">bye hello too</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>代码实现(reference)</p>
</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        code
    </div>
    <div class="spoiler-content">
        <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy</span><span class="params">(<span class="type">char</span> **p1, <span class="type">char</span> *p2)</span> &#123;</span><br><span class="line">    *p1 = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(p2) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(*p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readLine</span><span class="params">(<span class="type">char</span> **pars, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">char</span> buf[d];</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 读取1行</span></span><br><span class="line">    <span class="keyword">while</span> (read(<span class="number">0</span>, buf + j, <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="comment">// 按行划分</span></span><br><span class="line">        <span class="keyword">if</span> (buf[j] == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            buf[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span> (j == d)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parameters are too long!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有读取内容</span></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照空格划分</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; MAXARG)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Too much parameters!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &#x27;   abc   sdf&#x27;</span></span><br><span class="line">        <span class="comment">// 忽略</span></span><br><span class="line">        <span class="keyword">while</span> ((k &lt; j) &amp;&amp; (buf[k] == <span class="string">&#x27; &#x27;</span>))&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 起始位置</span></span><br><span class="line">        <span class="type">int</span> l = k;</span><br><span class="line">        <span class="comment">// 保留字符</span></span><br><span class="line">        <span class="keyword">while</span> ((k &lt; j) &amp;&amp; (buf[k] != <span class="string">&#x27; &#x27;</span>))&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意需要k++</span></span><br><span class="line">        buf[k++] = <span class="number">0</span>;</span><br><span class="line">        copy(&amp;pars[i], buf + l);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;error arg number&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> *args[MAXARG]; </span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; argc; i++, j++) &#123;</span><br><span class="line">            copy(&amp;args[j], argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        <span class="keyword">while</span> ((end = readLine(args, argc - <span class="number">1</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">            args[end] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// child</span></span><br><span class="line">                exec(args[<span class="number">0</span>], args);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h3 id="Optional-challenge-exercises-6">Optional challenge exercises</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Write an uptime program that prints the uptime in terms of ticks using the uptime system call. (easy)</p>
</li>
<li class="lvl-2">
<p>Support regular expressions in name matching for find. grep.c has some primitive support for regular expressions. (easy)</p>
</li>
<li class="lvl-2">
<p>The xv6 shell (user/sh.c) is just another user program and you can improve it.</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
        <tag>GNU Make</tag>
      </tags>
  </entry>
  <entry>
    <title>CS50ai</title>
    <url>/2023/03/28/CS50ai/</url>
    <content><![CDATA[<h3 id="Course-About">Course About</h3>
<p><strong>介绍有关人工智能的问题，内容包括搜索、优化、学习、神经网络等</strong></p>
<h3 id="Feeling">Feeling</h3>
<p>人工智能在今天已经是一个时代性的话题，仅仅是在这短短的一年之间，我已经见证了它对不同领域的冲击，从AI绘画到ChatGPT,或者是其他的更多方面，真正的AI时代似乎已经到来。以我肤浅的认识，以我在课程中学到的内容还有我粗浅的理解，我确实很难想象神经网络和反向传播，最后居然能训练出ChatGPT这样现象级的人工智能。绘画和CS都是我思考过想要投入其中的行业，我一方面明白人工智能的发展是科技进步的象征，它的应用必将让这个世界走向更加智能和美好的方向，但同时不可阻挡的发展，也正像浪潮一般席卷了从业者。我斗胆自诩为绘画行业的旁观者，又或者是踏入CS半只脚的半吊子，但我却深深体会到了AI所带来的追赶不上和将被替代的压迫感。我在以前无法预知现在的科技发展，而现在也仍然对未来的日子一无所知。我正像几年前的高考那样，迷茫地走向前去。我不知道人工智能的未来，甚至也不知道自己的未来。但即便如此，我还是想要去了解现代的人工智能，了解它的原理和实现，并且尝试去使用它。</p>
<h3 id="Links-2">Links</h3>
<ul class="lvl-0">
<li class="lvl-4">
<p><a href="https://cs50.harvard.edu/ai/2020/">课程主页</a></p>
</li>
<li class="lvl-4">
<p><a href="https://www.bilibili.com/video/BV1AQ4y1y7wy">课程视频</a></p>
</li>
</ul>
<p><strong>(Updating…)</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Make and CMake</title>
    <url>/2023/03/28/Make/</url>
    <content><![CDATA[<h2 id="Introduction-8">Introduction</h2>
<p>GNU Make是GNU项目中的构建工具，构建文件为Makefile。而CMake是更为强大的构建工具，构建文件为CMakeList.txt，CLion使用CMake作为其构建工具。</p>
<h2 id="Feeling-6">Feeling</h2>
<h2 id="Links-10">Links</h2>
<ul class="lvl-0">
<li class="lvl-2">
<h4 id="GNU-Make">GNU Make</h4>
<ul class="lvl-2">
<li class="lvl-5"><a href="https://seisman.github.io/how-to-write-makefile/overview.html">参考教程</a></li>
</ul>
</li>
<li class="lvl-2">
<h4 id="CMake">CMake</h4>
<ul class="lvl-2">
<li class="lvl-5"><a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">官方文档</a></li>
</ul>
</li>
</ul>
<p>Updating…</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Tools</category>
      </categories>
      <tags>
        <tag>GNU Make</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>CS61C</title>
    <url>/2023/03/27/CS61C/</url>
    <content><![CDATA[<h3 id="Course-About-2">Course About</h3>
<p><strong>介绍有关计算机组成的问题，内容包括电路设计、RISC-V汇编、CPU流水线等等</strong></p>
<h3 id="Feeling-2">Feeling</h3>
<h3 id="Links-3">Links</h3>
<ul class="lvl-0">
<li class="lvl-4">
<p><a href="https://inst.eecs.berkeley.edu/~cs61c/su20/">课程主页</a></p>
</li>
<li class="lvl-4">
<p><a href="https://inst.eecs.berkeley.edu/~cs61c/su20/">课程视频(在主页)</a></p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>C</tag>
        <tag>RISC-V</tag>
      </tags>
  </entry>
  <entry>
    <title>Git and Github</title>
    <url>/2023/03/27/Git-and-Github/</url>
    <content><![CDATA[<h2 id="Introduction-6">Introduction</h2>
<p>Git是Linus开发的分布式版本控制工具，而Github是在线代码托管平台</p>
<h2 id="Feeling-4">Feeling</h2>
<p>我常常觉得git/github对我来说只有<code>git add</code> <code>git commit</code> <code>git push</code>三部曲，别人的git版本控制是有向无环图(DAG), 而我的git是链表😆。但是学会完整的git/github工作流是必要的。</p>
<h2 id="Links-6">Links</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://git-scm.com/book/zh/v2">Pro Git</a> (一本在线Git学习书籍)</p>
</li>
<li class="lvl-2">
<p><a href="https://learngitbranching.js.org/?locale=zh_CN">使用练习</a></p>
</li>
</ul>
<p>Updating…</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.031: Software Construction</title>
    <url>/2023/03/26/MIT-6-031/</url>
    <content><![CDATA[<h3 id="Course-About-4">Course About</h3>
<p><strong>介绍有关软件工程的问题</strong></p>
<h3 id="Links-8">Links</h3>
<ul class="lvl-0">
<li class="lvl-4">
<p><a href="http://web.mit.edu/6.031/www/sp21/">课程主页</a></p>
</li>
</ul>
<p><strong>(Updating…)</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081: Operating System Engineering</title>
    <url>/2023/03/26/MIT-6-S081/</url>
    <content><![CDATA[<blockquote>
<p>Catalog description: Design and implementation of operating systems, and their use as a foundation for systems programming. Topics include virtual memory; file systems; threads; context switches; kernels; interrupts; system calls; interprocess communication; coordination, and interaction between software and hardware. A multi-processor operating system for RISC-V, xv6, is used to illustrate these topics. Individual laboratory assignments involve extending the xv6 operating system, for example to support sophisticated virtual memory features and networking.</p>
</blockquote>
<h3 id="Feeling-5">Feeling</h3>
<p>操作系统层的编程以它注重硬件直接交互，兼顾性能与安全的特征而为人所知。操作系统和机器架构方面的问题，时常让我在想，先有鸡还是先有蛋。所谓的Shell是内核之外的用户程序，它执行不同种类的系统调用以让我觉得，Shell就是内核的包装和外壳(Shell)。但是在Shell之前的事情呢，机器如何摆放它在屏幕上的文字，以让我觉得我在使用Shell？如果没有Shell，事情又会变得怎样呢？网络是一种I/O设备，它在操作系统下的接口是怎样的？我们所熟悉的C语言中那些理所应当的函数和数据结构，是怎样由操作系统封装提供的？操作系统是硬件与用户层之间的重要桥梁，它不仅仅是某种&quot;Cache&quot;，不仅仅是某种GUI，它是很多东西的集合和封装，但幸运的是，它是运行中的程序，它不由谁提供环境，它要自己适应环境。</p>
<h3 id="Links-9">Links</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">课程主页(Fall21)</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.bilibili.com/video/BV1rS4y1n7y1">课程视频</a></p>
</li>
<li class="lvl-2">
<p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/">课程视频翻译</a></p>
</li>
<li class="lvl-2">
<p><a href="https://th0ar.gitbooks.io/xv6-chinese/content/index.html">xv6 中文文档</a></p>
</li>
</ul>
<p><strong>(Updating…)</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OS</tag>
        <tag>RISC-V</tag>
      </tags>
  </entry>
  <entry>
    <title>Maki Abstract algebra</title>
    <url>/2023/03/26/Maki-%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<h3 id="Course-About-5">Course About</h3>
<p><strong>抽象代数I是用代数方法研究代数结构的第一门课。介绍群论、环论、多项式理论和域论的基础知识。先修课程是数学分析和高等代数。</strong></p>
<h3 id="Links-11">Links</h3>
<ul class="lvl-0">
<li class="lvl-4">
<p><a href="https://www.maki-math.com/#/courses/21">课程主页</a></p>
</li>
<li class="lvl-4">
<p><a href="https://www.bilibili.com/video/BV1xG411j7Hk">课程视频</a></p>
</li>
</ul>
<p><strong>(Updating…)</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>抽象代数</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Maki Topology</title>
    <url>/2023/03/26/Maki-%E7%82%B9%E9%9B%86%E6%8B%93%E6%89%91%E5%AD%A6/</url>
    <content><![CDATA[<h3 id="Course-About-6">Course About</h3>
<p><strong>介绍了拓扑空间、连续映射、经典的拓扑不变量以及一些重要的拓扑学定理。</strong></p>
<h3 id="Links-12">Links</h3>
<ul class="lvl-0">
<li class="lvl-4">
<p><a href="https://www.maki-math.com/#/courses/83">课程主页</a></p>
</li>
<li class="lvl-4">
<p><a href="https://www.bilibili.com/video/BV1NG4y1k7DM/">课程视频</a></p>
</li>
<li class="lvl-4">
<p><a href>课程讲义</a></p>
</li>
<li class="lvl-4">
<p>参考书籍</p>
</li>
</ul>
<span id="more"></span>
<h3 id="第1讲-R上的通常拓扑">第1讲 R上的通常拓扑</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>这节课的开始大致为我们讲述了点集拓扑的背景和点集拓扑学研究的对象，这门课将从$R$上的通常拓扑开始，从具体到抽象一步步地为我们揭开拓扑的本质。</p>
</li>
<li class="lvl-2">
<p>拓扑空间是一个集合</p>
</li>
<li class="lvl-2">
<p>拓扑空间中开集的集合-&gt;{开集} 被称为拓扑</p>
</li>
<li class="lvl-2">
<p>点集拓扑学的研究对象是拓扑空间，拓扑，连续映射，同胚映射，拓扑不变量等</p>
</li>
<li class="lvl-2">
<p>本节课建立在$R$上的通常拓扑下</p>
</li>
</ul>
<h4 id="定义1-1"><code>定义1.1</code></h4>
<p>$ 若x\in R, \varepsilon &gt; 0,则以x为圆心,\varepsilon为半径的开球，记作B(x, \varepsilon),定义为B(x, \varepsilon) = \{ y\in R: |y - x| &lt; \varepsilon \}。 $</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这个定义实际上就是$\varepsilon$-邻域的概念，它定义了一个点的“附近”，在后面我们将学习到，这种附近的定义的延伸就是$R$上的通常拓扑，如果换一种“附近”的定义，就会得到不同的拓扑。</p>
</li>
</ul>
<h4 id="命题1-1"><code>命题1.1</code></h4>
<p>$<br>
若I是一个开区间，则对于任意x\in I，存在\varepsilon &gt; 0，使得B(x, \varepsilon) \subset I。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这是开区间的定义，意思是对于开区间的任一点，开区间会包含每一个点的小邻域</p>
</li>
</ul>
<h4 id="定义1-2"><code>定义1.2</code></h4>
<p>$<br>
若 U \subset R，则 U 被称为 R 上的一个开集，若对于任意 x \in U，存在 \varepsilon &gt; 0，使得B(x, \varepsilon) \subset U。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这是开集的定义，显然开区间都是开集，但反过来，开集不一定是开区间</p>
</li>
</ul>
<h4 id="定义1-3"><code>定义1.3</code></h4>
<p>$<br>
若 A \subset R，则 x \in R 被称为 A 的一个极限点，若存在 A 中的一个数列 (a_{n}) \subset A，使得 \lim_{n \to \infty} a_{n} = x。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这是子集的极限点的定义</p>
</li>
</ul>
<h4 id="引理1-1"><code>引理1.1</code></h4>
<p>$<br>
若 A \subset R，则 x \in R 是 A 的一个极限点，当且仅当，对于任意 \varepsilon &gt; 0，都可以找到 a \in A，使得 |a - x| &lt; \varepsilon<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这在微积分和数学分析中显然</p>
</li>
</ul>
<h4 id="命题1-2"><code>命题1.2</code></h4>
<p>$<br>
若I是一个闭区间，则它包含所有I的极限点。换言之，如果x是I的一个极限点，那么x \in I。<br>
$</p>
<h4 id="定义1-4"><code>定义1.4</code></h4>
<p>$<br>
若 V 是 R 的一个子集，则它被称为 R 的一个闭集，若每一个 V的极限点都在 V 中。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>显然，闭区间都是闭集。</p>
</li>
</ul>
<h4 id="命题1-3"><code>命题1.3</code></h4>
<p>$<br>
令 U 是 R 的一个子集，则 U 是 R 中的一个开集当且仅当 V = R − U是 R 中的一个闭集。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>一个至关重要的结论，就是说，开集和闭集是相补的。</p>
</li>
</ul>
<h3 id="第2讲-R上的通常拓扑">第2讲 R上的通常拓扑</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>这节课对开集和闭集的性质进行了讲解，同时也阐述了集合的内部与外部的含义</p>
</li>
<li class="lvl-2">
<p>还是要注意本节内容都是相对于R上的通常拓扑而言</p>
</li>
<li class="lvl-2">
<p>要更注重数学框架、逻辑推导本身，而不是只注重数学表达的名词和语言</p>
</li>
</ul>
<h4 id="命题1-4（R中开集的性质）"><code>命题1.4（R中开集的性质）</code></h4>
<p>$<br>
1.\phi, R 都是 R 中的开集。\newline<br>
2.若 U_{a} 对任意 a \in I 都是 R 中的开集，则 \bigcup_{a \in I} U_{a} 也是 R 中的开集。\newline<br>
3.若 U_{1}, · · · , U_{n} 都是 R 中的开集，则 \bigcap_{i=1}^{n}U_{i} 也是 R 中的开集。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>证明</code></p>
</li>
<li class="lvl-2">
<p>1显然成立</p>
</li>
<li class="lvl-2">
<p>2是说开集对任意并封闭</p>
</li>
<li class="lvl-2">
<p>3是说开集对有限交封闭</p>
</li>
</ul>
<h4 id="命题1-5（R中闭集的性质）"><code>命题1.5（R中闭集的性质）</code></h4>
<p>$<br>
1.\phi, R 都是 R 中的闭集。\newline<br>
2.若 U_{a} 对任意 a \in I 都是 R 中的闭集，则 \bigcap_{a \in I} U_{a} 也是 R 中的闭集。 \newline<br>
3.若 U_{1}, · · · , U_{n} 都是 R 中的闭集，则 \bigcup_{i=1}^{n}U_{i} 也是 R 中的闭集。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>1显然成立</p>
</li>
<li class="lvl-2">
<p>2是说闭集对任意交封闭</p>
</li>
<li class="lvl-2">
<p>3是说闭集对有限并封闭</p>
</li>
<li class="lvl-2">
<p>闭集的性质在R上可以退出闭区间套定理</p>
</li>
<li class="lvl-2">
<p>由德摩根律结合开集的性质，闭集的性质显然成立</p>
</li>
</ul>
<p><code>引理：De Morgan律</code><br>
$<br>
(A \bigcap B)^{C} = A^{C} \bigcup B^{C}<br>
\newline<br>
(A \bigcup B)^{C} = A^{C} \bigcap B^{C}<br>
\newline<br>
( \bigcap_{i = 1}^{n} A_{i})^{C} = \bigcup_{i = 1}^{n} {A_{i}}^{C}<br>
\newline<br>
( \bigcup_{i = 1}^{n} A_{i})^{C} = \bigcap_{i = 1}^{n} {A_{i}}^{C}<br>
\newline<br>
(\bigcap_{\alpha \in I}A_{\alpha})^{C} = \bigcup_{\alpha \in I} {A_{\alpha}}^{C}<br>
\newline<br>
(\bigcup_{\alpha \in I}A_{\alpha})^{C} = \bigcap_{\alpha \in I} {A_{\alpha}}^{C}<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>证明</code></p>
</li>
</ul>
<h4 id="定义-1-5"><code>定义 1.5</code></h4>
<p>$<br>
令 A 是 R 的一个子集，则 A 的闭包，记作 cl(A) = \bar{A}，定义为由 A 的所有极限点构成的集合。<br>
$</p>
<h4 id="引理1-2"><code>引理1.2</code></h4>
<p>$<br>
𝑉 是 R 的闭子集当且仅当 V = \bar{V}。<br>
$</p>
<h4 id="定义1-6"><code>定义1.6</code></h4>
<p>$<br>
令 A 是 R 的一个子集。<br>
\newline<br>
1.A 的内部，记作 Int(A)，定义为 \{  x \in R: \exists  \varepsilon &gt; 0, B(x, \varepsilon) \subset A \} = \{ x \in R: \exists \varepsilon &gt; 0, 𝐵(x, \varepsilon) \cap A^{C} = \phi \}。<br>
\newline<br>
2.A 的外部，记作 Ext(A)，定义为 \{ x \in R: \exists \varepsilon &gt; 0, 𝐵(x, \varepsilon) \subset A^{C} \} = \{ x \in R: \exists \varepsilon &gt; 0, 𝐵(x, \varepsilon) \cap A = \phi \}。<br>
\newline<br>
3.A 的边界，记作 \partial (A)，定义为 \{ x \in R: \forall \varepsilon &gt; 0, 𝐵(x, \varepsilon) \cap A \ne 0 且 𝐵(x, \varepsilon) \cap A^{C} \ne 0 \}。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这三个形象的定义为我们描绘了R上的通常拓扑</p>
</li>
</ul>
<h3 id="第3讲-R上的通常拓扑">第3讲 R上的通常拓扑</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>这节课为我们介绍了集合的内部、外部、边界的性质</p>
</li>
</ul>
<h4 id="引理1-3"><code>引理1.3</code></h4>
<p>$<br>
令 A 是 R 的一个子集，则 Int(A) \cap Ext(A) = \phi。<br>
$</p>
<h4 id="引理1-4"><code>引理1.4</code></h4>
<p>$<br>
1.Int(A) \subset A。<br>
\newline<br>
2.Ext(A) \subset A = \phi。<br>
\newline<br>
3.Int(A) 和 Ext(A) 是两个开集。<br>
\newline<br>
4.A \cup \partial A = Int(A) \sqcup \partial A 是一个闭集。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>证明</code></p>
</li>
</ul>
<h4 id="命题1-6"><code>命题1.6</code></h4>
<p>$<br>
令 A 是 R 的一个子集，则<br>
\newline<br>
1.A 是开集当且仅当 A = Int(A)。<br>
\newline<br>
2.\bar{A} = A \cup \partial A = Int(A) \sqcup \partial A。<br>
\newline<br>
3.A是闭集当且仅当 \partial A \subset A。<br>
$</p>
<h4 id="命题1-7"><code>命题1.7</code></h4>
<p>$<br>
令 A 是 R 的一个子集，则<br>
\newline<br>
1.Int(A) 是 A 中最大的开集。<br>
\newline<br>
2.\bar{A} 是包含了 A 的最小的闭集。<br>
$</p>
<h4 id="命题1-8"><code>命题1.8</code></h4>
<p>$<br>
令 A 是 R 的一个子集，则<br>
\newline<br>
1.(Int(A))^{C} = \bar{A^{C}}<br>
\newline<br>
2.(\bar{A})^{C} = Int(A^{C})<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>证明</code></p>
</li>
<li class="lvl-2">
<p>$(Int(A))^{C} =  \partial A \sqcup Ext(A) = \partial (A^{C}) \sqcup Int(A^{C}) = \bar{A^{C}}$</p>
</li>
<li class="lvl-2">
<p>由于两个结论对称，将$A$换成$A^{C}$，二式显然成立</p>
</li>
</ul>
<h3 id="第4讲-R上的连续映射">第4讲 R上的连续映射</h3>
<h4 id="定义1-7"><code>定义1.7</code></h4>
<p>$<br>
f: R \to R 被称为一个连续映射，若对于任意 x \in R 和任意 \varepsilon &gt; 0，都存在一个 \delta &gt; 0，\newline<br>
使得对任意 y，只要 |x - y| &lt; \delta ，就有 |f(x) - f(y)| &lt; \varepsilon<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这其实等价于说<br>
$<br>
对R中任何一个形如B(f(x), \varepsilon) 的开球，我们都能找到一个形如 B(x, \delta) 的开球，使得f(B(x, \delta)) \subset B(f(x), \varepsilon)。<br>
$</p>
</li>
</ul>
<h4 id="命题1-9"><code>命题1.9</code></h4>
<p>$<br>
f: R \to R 是一个连续映射，当且仅当对任意 R 中的开子集 U，我们都有 f^{-1}(U)是R的开子集<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这个定义的意思是开集的原像是开集</p>
</li>
</ul>
<h4 id="定义1-8"><code>定义1.8</code></h4>
<p>$<br>
f : R \to R 被称为一个同胚映射，若 \newline<br>
1.f 是一个双射。\newline<br>
2.f 是一个连续映射。\newline<br>
3.f^{-1} 是一个连续映射。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在R上同胚的定义由1 2可以推出3，而在一般的拓扑空间就不行了</p>
</li>
</ul>
<h4 id="引理1-5"><code>引理1.5</code></h4>
<p>$<br>
若 f : R \to R 是一个连续的单射，则 f 要么在 R 上是严格递增的，要么在 R 上是严格递减的。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数学分析中显然</p>
</li>
</ul>
<h4 id="命题1-10"><code>命题1.10</code></h4>
<p>$<br>
若 f : R \to R 是一个连续的双射，则 f 是一个同胚。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>$R^{n}$上也是成立的，但是证明要用到代数拓扑的知识</p>
</li>
</ul>
<h3 id="第5讲-度量空间">第5讲 度量空间</h3>
<h4 id="定义1-9"><code>定义1.9</code></h4>
<p>$<br>
令 x \in R^{n}，而 \varepsilon &gt; 0，则 B(x, \varepsilon) = \{ y \in R^{n}: d(x, y) = |x − y| &lt; \varepsilon  \}。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这是一个赋范空间上的开球定义</p>
</li>
<li class="lvl-2">
<p>不同空间的关系：内积-&gt;赋范(长度)-&gt;度量(距离)-&gt;拓扑</p>
</li>
<li class="lvl-2">
<p>完备的内积空间叫做Hirbert空间</p>
</li>
<li class="lvl-2">
<p>内积空间涉及到泛函分析的方向</p>
</li>
<li class="lvl-2">
<p>完备的赋范空间叫做Banach空间</p>
</li>
<li class="lvl-2">
<p>赋范空间的定义如下<br>
$<br>
|.|: R^{n} \to R(R^{n}是R上的赋范空间)<br>
\newline<br>
1.\forall x \in R^{n}, |x| \ge 0 且 \newline<br>
|x| = 0 \Leftrightarrow  x = 0<br>
\newline<br>
2.c \in R, \forall x \in R^{n}, |cx| = |c||x|<br>
\newline<br>
3.\forall x, y \in R^{n},|x+y| \le |x|+|y|<br>
$</p>
</li>
</ul>
<h4 id="定义1-10"><code>定义1.10</code></h4>
<p>$<br>
令U 是 R^{n}的一个子集，则U被称为一个 R^{n}的开子集，若对任意 x \in U，存在一个 \varepsilon &gt; 0，使得 B(x, \varepsilon) \subset U。<br>
$</p>
<h4 id="引理1-6"><code>引理1.6</code></h4>
<p>$<br>
1.令 x, y ∈ R^{n}，则 |x + y| \le |x| + |y|。<br>
\newline<br>
2.令 x, y, z ∈ R^{n}，则 d(x, z) ≤ d(x, y) + d(y, z)。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这分别是赋范空间和度量空间中的三角不等式</p>
</li>
</ul>
<h4 id="引理1-7"><code>引理1.7</code></h4>
<p>$<br>
令 x \in R^{n}，而 \varepsilon &gt; 0，则 B(x, \varepsilon) 是一个 R^{n}的开子集。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>$R^{n}$上的开球都是开集</p>
</li>
</ul>
<h4 id="定义1-11"><code>定义1.11</code></h4>
<p>$<br>
令 X 是一个非空集合，则 d : X × X \to R 被称为 X 上的一个度量，若<br>
\newline<br>
1.（正定性）对任意 x, y \in X，我们有 d(x, y) ≥ 0。此外，对任意 x, y \in X，我们有 d(x, y) = 0  \Leftrightarrow x = y；<br>
\newline<br>
2.（对称性）对任意 x, y \in X，我们有 d(x, y) = d(y, x)；<br>
\newline<br>
3.（三角不等式）对任意 x, y, z \in X，我们有 d(x, z) ≤ d(x, y) + 𝑑(y, z)。<br>
\newline<br>
进一步，我们称 (X, d) 是一个度量空间。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这是抽象后的度量空间的定义，每一个度量空间都可以引出一个拓扑</p>
</li>
</ul>
<h4 id="定义1-12"><code>定义1.12</code></h4>
<p>$<br>
令 X 是一个集合，则 \tau \subset P (X) 是 X 上的一个拓扑，若<br>
\newline<br>
1.\phi, X \in \tau；<br>
\newline<br>
2.如果对任意 a \in I，我们有 U_{a} \in \tau，则它们的任意并也在 \tau 中,即\cup_{a \in I}U_{a} \in \tau<br>
\newline<br>
3.如果U_{1}…U_{i} \in \tau, 则\cap_{i=1}^{n} \in \tau<br>
\newline<br>
我们称 (X, \tau) 是一个拓扑空间。在不引起歧义的情况下，我们简单地称 X 是一个拓扑空间。<br>
\newline<br>
进一步地，A \subset X 被称为一个开集当且仅当 A \in \tau，A 被为一个闭集当且仅当 A^{C} = X - A是一个开集。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这里提前给出拓扑的定义</p>
</li>
</ul>
<h4 id="命题1-10-2"><code>命题1.10</code></h4>
<p>$<br>
假设 (X, d) 是一个度量空间，则 U \subset X 被称为一个 (X, d) 一个开子集，当且仅当对于 x \in U，存在 \varepsilon &gt; 0，使得 B(x, \varepsilon) \subset U。<br>
$</p>
<h4 id="定义1-13"><code>定义1.13</code></h4>
<p>$<br>
如上定义的开集给出了 (X, d) 的一个拓扑结构。换言之，上面定义的开集满足拓扑空间的三条公理。<br>
$</p>
<h4 id="定义1-14"><code>定义1.14</code></h4>
<p>$<br>
假设 (X, d) 是一个度量空间，x \in X，A, B 是 X 的两个非空子集，则<br>
\newline<br>
1.A 的直径，记作 diam(A)，定义为 diam(A) = sup_{x, y \in A}d(x, y)；<br>
\newline<br>
2.x 和 A 的距离，记作 d(x, A)，定义为 d(x, A) = inf_{y \in A} 𝑑(𝑥, 𝑦)；<br>
\newline<br>
3.A 和 B 的距离，记作 d(A, B)，定义为 d(A, B) = inf_{x \in A, y \in B}d(x,y)。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>sup上确界</p>
</li>
<li class="lvl-2">
<p>inf下确界</p>
</li>
</ul>
<h4 id="定义1-15"><code>定义1.15</code></h4>
<p>$<br>
我们称非空子集 A \subset X 是个有界集合，若 diam(A) &lt; \infty<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>直径可以无穷，但距离不能无穷</p>
</li>
</ul>
<h4 id="引理1-8"><code>引理1.8</code></h4>
<p>$<br>
令 A 是 X 的一个非空子集，而 x, y \in X，则 d(x, A) ≤ d(x, y) + d(y, A)。<br>
$</p>
<h4 id="定义1-16"><code>定义1.16</code></h4>
<p>$<br>
令 (X, d)，(Y, d′) 是两个度量空间，则 f : X \to Y 是一个连续映射，<br>
\newline<br>
若对于任意 x \in X 和 \varepsilon &gt; 0，存在一个 \delta &gt; 0，使得对任意 y \in X，只要 d(x, y) &lt; \delta，就有 d′(f(x), f(y)) &lt; \varepsilon。<br>
$</p>
<h4 id="命题1-12"><code>命题1.12</code></h4>
<p>$<br>
令 (X, d)，(Y, d’) 是两个度量空间，则 f:X \to Y 是一个连续映射，<br>
\newline<br>
当且仅当对任意 Y 中的开集 U，我们有 f^{-1}(U)是 𝑋 中的一个开集。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这其实也是拓扑空间中连续映射的定义，开集的原像是开集</p>
</li>
</ul>
<h3 id="第6讲-拓扑空间">第6讲 拓扑空间</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>这节课从抽象的度量空间介绍到了更为抽象的拓扑空间，抽象的东西从“距离”变成了“附近”。</p>
</li>
</ul>
<h4 id="定义1-17"><code>定义1.17</code></h4>
<p>$<br>
令 X 是一个集合，则 \tau \subset P (X) 是 X 上的一个拓扑，若<br>
\newline<br>
1.\phi, X \in \tau；<br>
\newline<br>
2.如果对任意 a \in I，我们有 U_{a} \in \tau，则它们的任意并也在 \tau 中,即\cup_{a \in I}U_{a} \in \tau<br>
\newline<br>
3.如果U_{1}…U_{i} \in \tau, 则\cap_{i=1}^{n} \in \tau<br>
\newline<br>
我们称 (X, \tau) 是一个拓扑空间。在不引起歧义的情况下，我们简单地称 X 是一个拓扑空间。<br>
\newline<br>
进一步地，A \subset X 被称为一个开集当且仅当 A \in \tau，A 被为一个闭集当且仅当 A^{C} = X - A是一个开集。<br>
$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>X在任意并和有限交下封闭</p>
</li>
<li class="lvl-2">
<p>P(x)是X所有子集的集合</p>
</li>
</ul>
<h3 id="第7讲-连续映射">第7讲 连续映射</h3>
<h3 id="第8讲-拓扑的基与子空间拓扑">第8讲 拓扑的基与子空间拓扑</h3>
<h3 id="第9讲-积拓扑与箱拓扑">第9讲 积拓扑与箱拓扑</h3>
<h3 id="第10讲-商拓扑与序拓扑">第10讲 商拓扑与序拓扑</h3>
<p><strong>(Updating…)</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>点集拓扑</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>C++</title>
    <url>/2022/07/14/C-Tips/</url>
    <content><![CDATA[<h3 id="Introduction-3">Introduction</h3>
<p>C++是一种兼具面向过程和面向对象特征的编程语言</p>
<span id="more"></span>
<h3 id="Start">Start</h3>
<ul class="lvl-0">
<li class="lvl-2"><strong>让我们写下第一个C++文件!</strong></li>
</ul>
<figure class="highlight cpp"><figcaption><span>hello.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>使用Linux命令行来调用编译器</strong></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -o hello hello.cpp</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>运行编译好的程序</strong></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Language</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown and Latex</title>
    <url>/2022/07/14/MarkdownHelp/</url>
    <content><![CDATA[<h2 id="Introduction-10">Introduction</h2>
<p>Markdown是一种标记语言，而Latex是一种排版系统</p>
<span id="more"></span>
<h2 id="Usage-2">Usage</h2>
<h3 id="标题">标题</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Title</span></span><br><span class="line"><span class="section">## Title</span></span><br><span class="line"><span class="section">### Title</span></span><br><span class="line"><span class="section">#### Title</span></span><br><span class="line"><span class="section">##### Title</span></span><br><span class="line"><span class="section">###### Title</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="引用">引用</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; Learn what is to be taken seriously and laugh at the rest.</span></span><br><span class="line"><span class="quote">&gt; ― Herman Hesse</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Learn what is to be taken seriously and laugh at the rest.<br>
― Herman Hesse</p>
</blockquote>
<hr>
<h3 id="强调">强调</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*斜体加粗*</span>**</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">==高亮==</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 重点</span><br><span class="line"><span class="bullet">+</span> 重点</span><br><span class="line"><span class="bullet">-</span> 重点</span><br></pre></td></tr></table></figure>
<p><em>斜体</em></p>
<p><strong>加粗</strong></p>
<p><em><strong>斜体加粗</strong></em></p>
<p><u>下划线</u></p>
<p><mark>高亮</mark></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>重点</p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<p>重点</p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<p>重点</p>
</li>
</ul>
<hr>
<h3 id="链接">链接</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">mygithub</span>](<span class="link">https://github.com/huaeryi</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/huaeryi">mygithub</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">我的github</span>](<span class="link">https://github.com/huaeryi &quot;https://github.com/huaeryi&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/huaeryi" title="https://github.com/huaeryi">我的github</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> mygithub[^website]</span><br><span class="line">[<span class="symbol">^website</span>]:<span class="link">https://github.com/huaeryi</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>mygithub<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">picture</span>](<span class="link">/MarkdownHelp/Head.jpg =300x300</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/14/MarkdownHelp/Head.jpg" alt="picture" width="300" height="300"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">ok</span>](<span class="link">/First/pic.jpg &quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/14/MarkdownHelp/pic.jpg" alt="ok" title="hello"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">reference to Others</span>](<span class="link">#Others</span>)</span><br></pre></td></tr></table></figure>
<p><a href="#Others">reference to Others</a></p>
<hr>
<h3 id="代码">代码</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`$ echo &quot;El Psy Kongroo&quot;`</span></span><br></pre></td></tr></table></figure>
<p><code>$ echo &quot;El Psy Kongroo&quot;</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">//忽略斜杠</span><br><span class="line">//<span class="code">```cpp</span></span><br><span class="line"><span class="code">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="code">int main()</span></span><br><span class="line"><span class="code">&#123;</span></span><br><span class="line"><span class="code">    using namespace std;</span></span><br><span class="line"><span class="code">    cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="code">    return 0;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">//```</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="表情">表情</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">:smile:</span><br><span class="line">:laughing:</span><br></pre></td></tr></table></figure>
<p>😄<br>
😆</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://funletu.com/emoji/" title="https://funletu.com/emoji/">emoji表情大全</a></p>
</li>
</ul>
<hr>
<h3 id="Latex">Latex</h3>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\alpha</span> = <span class="keyword">\delta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$\alpha = \delta$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\alpha</span> = <span class="keyword">\delta</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>$$<br>
\alpha = \delta<br>
$$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://zhuanlan.zhihu.com/p/510451940">LaTeX数学公式、常用符号大全</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.latexlive.com/">在线编辑器</a></p>
</li>
</ul>
<hr>
<h3 id="Others">Others</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> X^2^</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>X<sup>2</sup></p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] home</span><br><span class="line"><span class="bullet">-</span> [x] homework</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox0"><label for="checkbox0">home</label></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">homework</label></p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">+++ <span class="strong">**点击折叠**</span></span><br><span class="line">这是被隐藏的内容</span><br><span class="line">+++</span><br></pre></td></tr></table></figure>
<details open>
<summary><span class="pre-summary">&nbsp;</span><strong>点击折叠</strong></summary><p>这是被隐藏的内容</p>
</details>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|name|age|mark</span><br><span class="line">|:---:|:---:|:---:|</span><br><span class="line">|peter|20|80|</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">age</th>
<th style="text-align:center">mark</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">peter</td>
<td style="text-align:center">20</td>
<td style="text-align:center">80</td>
</tr>
</tbody>
</table>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://github.com/huaeryi">https://github.com/huaeryi</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CS Tools</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>First</title>
    <url>/2022/07/13/First/</url>
    <content><![CDATA[<h1>First</h1>
<h2 id="This-is-my-First-Markdown-file">This is my First Markdown file.</h2>
<ul class="lvl-0">
<li class="lvl-2"><a href="#First">reference to title</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/05/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
</search>
